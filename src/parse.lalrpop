use crate::data::intrinsics::Intrinsic as Intr;
use crate::data::purity::Purity;
use crate::data::raw_ast as raw;
use crate::data::visibility::Visibility;
use crate::file_cache::FileId;
use crate::report_error::Span;
use crate::{ErrorId, lex};
use id_collections::IdVec;
use lalrpop_util::ErrorRecovery;

grammar<'a, 'b>(
  file: FileId,
  store: &'a mut raw::Store,
  errors: &'b mut IdVec<ErrorId, ErrorRecovery<usize, lex::Token, lex::Error>>,
);

// Lexer Integration

extern {
  type Location = usize;
  type Error = lex::Error;

  enum lex::Token {
    "error" => lex::Token::Error(<char>),

    "UpperName" => lex::Token::UpperName(<String>),
    "LowerName" => lex::Token::LowerName(<String>),
    "FloatLit" => lex::Token::FloatLit(<f64>),
    "ByteLit" => lex::Token::ByteLit(<u8>),
    "IntLit" => lex::Token::IntLit(<i64>),
    "StringLit" => lex::Token::StringLit(<String>),

    "type" => lex::Token::Type,
    "match" => lex::Token::Match,
    "if" => lex::Token::If,
    "else" => lex::Token::Else,
    "let" => lex::Token::Let,
    "in" => lex::Token::In,
    "proc" => lex::Token::Proc,
    "do" => lex::Token::Do,
    "then" => lex::Token::Then,
    "module" => lex::Token::Module,
    "import" => lex::Token::Import,
    "file" => lex::Token::File,
    "from" => lex::Token::From,
    "expose" => lex::Token::Expose,
    "with" => lex::Token::With,
    "as" => lex::Token::As,
    "pub" => lex::Token::Pub,

    "(" => lex::Token::LParen,
    ")" => lex::Token::RParen,
    "[" => lex::Token::LSquare,
    "]" => lex::Token::RSquare,
    "{" => lex::Token::LCurly,
    "}" => lex::Token::RCurly,

    "," => lex::Token::Comma,
    ":" => lex::Token::Colon,
    "=" => lex::Token::Equal,
    "->" => lex::Token::Arrow,
    "\\" => lex::Token::BackSlash,
    "_" => lex::Token::Underscore,
    "." => lex::Token::Dot,
    "<|" => lex::Token::PipeLeft,
    "|>" => lex::Token::PipeRight,

    "+&" => lex::Token::AddAmp,
    "-&" => lex::Token::SubAmp,
    "*&" => lex::Token::MulAmp,
    "/&" => lex::Token::DivAmp,
    "=&" => lex::Token::EqualAmp,
    "<&" => lex::Token::LtAmp,
    "<=&" => lex::Token::LteAmp,
    ">&" => lex::Token::GtAmp,
    ">=&" => lex::Token::GteAmp,
    "+" => lex::Token::Add,
    "-" => lex::Token::Sub,
    "*" => lex::Token::Mul,
    "/" => lex::Token::Div,
    "<" => lex::Token::Lt,
    "<=" => lex::Token::Lte,
    ">" => lex::Token::Gt,
    ">=" => lex::Token::Gte,
    "+." => lex::Token::AddDot,
    "-." => lex::Token::SubDot,
    "*." => lex::Token::MulDot,
    "/." => lex::Token::DivDot,
    "=." => lex::Token::EqualDot,
    "<." => lex::Token::LtDot,
    "<=." => lex::Token::LteDot,
    ">." => lex::Token::GtDot,
    ">=." => lex::Token::GteDot,

    "!" => lex::Token::Exclamation,
    "&&" => lex::Token::DoubleAmp,
    "||" => lex::Token::DoubleBar,
  }
}

// Macros

CommaSep<T>: Vec<T> = {
  <items: (<T> ",")*> <last: T?> => match last {
    None => items,
    Some(item) => {
      let mut result = items;
      result.push(item);
      result
    }
  }
};

SpannedItem<T>: raw::Item = {
  <lo: @L> <data: T> <hi: @R> => {
    raw::Item::new(store, Span::new(file, lo, hi), data)
  },
};

SpannedType<T>: raw::Type = {
  <lo: @L> <data: T> <hi: @R> => {
    raw::Type::new(store, Span::new(file, lo, hi), data)
  },
};

SpannedExpr<T>: raw::Expr = {
  <lo: @L> <data: T> <hi: @R> => {
    raw::Expr::new(store, Span::new(file, lo, hi), data)
  },
};

SpannedPattern<T>: raw::Pattern = {
  <lo: @L> <data: T> <hi: @R> => {
    raw::Pattern::new(store, Span::new(file, lo, hi), data)
  },
};

// Names and Strings

#[inline]
TypeName: raw::TypeName = {
  <"UpperName"> => raw::TypeName(<>),
};

#[inline]
CtorName: raw::CtorName = {
  <"UpperName"> => raw::CtorName(<>),
};

#[inline]
TypeParam: raw::TypeParam = {
  <"LowerName"> => raw::TypeParam(<>),
};

#[inline]
ValName: raw::ValName = {
  <"LowerName"> => raw::ValName(<>),
};

#[inline]
ModName: raw::ModName = {
  <"UpperName"> => raw::ModName(<>),
};

#[inline]
OptProc: Purity = {
  "proc" => Purity::Impure,
  () => Purity::Pure,
};

#[inline]
OptPub: Visibility = {
  "pub" => Visibility::Public,
  () => Visibility::Private,
}

// Top-Level Items

pub Program: raw::Program = {
  <Item*> => raw::Program(<>),
};

Item: raw::RawResult<raw::Item> = {
  <item: TypeDef> => Ok(<>),
  <item: ValDef> => Ok(<>),
  <item: ModDef> => Ok(<>),
  <item: ModImport> => Ok(<>),
  <item: ModExpose> => Ok(<>),
};

// Type Definitions

TypeDef_: raw::ItemData = {
  <visibility: OptPub> "type" <name: TypeName> <params: TypeParam*>
    "{" <cases: CommaSep<TypeCase>> "}" =>
      raw::ItemData::TypeDef(visibility, name, params, cases),
};

TypeDef: raw::Item = {
  <SpannedItem<TypeDef_>>,
};

TypeCase: raw::RawResult<(Visibility, raw::CtorName, Option<raw::Type>)> = {
  <visibility: OptPub> <name: CtorName> <content: ("(" <Types> ")")?> =>
    Ok((visibility, name, content)),
};

// Value Definitions

ValDef_: raw::ItemData = {
  <visibility: OptPub>
  <purity: OptProc>
  <name: ValName>
  <args_lo: @L> "(" <args: CommaSep<(<@L> <ValName> <@R> ":" <Type>)>> ")" <args_hi: @R>
  ":" <ret_type: Type>
  "=" <body: Expr> => {
    let (arg_pat, arg_type) = if args.len() == 1 {
      let (lo, arg_name, hi, arg_type) = args.into_iter().next().unwrap();
      let pat = raw::PatternData::Var(arg_name);
      let pat = raw::Pattern::new(store, Span::new(file, lo, hi), pat);
      (pat, arg_type)
    } else {
      let mut pat_items = Vec::new();
      let mut type_items = Vec::new();

      for (lo, pat_item, hi, type_item) in args {
        let pat = raw::PatternData::Var(pat_item);
        let pat = raw::Pattern::new(store, Span::new(file, lo, hi), pat);
        pat_items.push(pat);
        type_items.push(type_item);
      }

      let pat = raw::Pattern::new_unspanned(store, raw::PatternData::Tuple(pat_items));
      let type_ = raw::Pattern::new_unspanned(store, raw::PatternData::Tuple(type_items));
      (pat, type_)
    };

    let def_type = raw::Type::Func(purity, arg_type, ret_type);
    let def_body = raw::Expr::Lam(purity, arg_pat, body);

    raw::ItemData::ValDef(visibility, name, def_type, def_body)
  },
  <visibility: OptPub> <name: ValName> ":" <def_type: Type> "=" <val: Expr> => {
    raw::ItemData::ValDef(visibility, name, def_type, val)
  },
}

ValDef: raw::Item = {
  <SpannedItem<ValDef_>>,
};

// Module Defintions

ModDef_: raw::ItemData = {
  <visibility: OptPub> "module" <name: ModName> "=" <spec: ModSpec>
  <bindings: ("with" "{" <CommaSep<ModBinding>> "}")?>
  <expose: OptExposeSpec> =>
    raw::ItemData::ModDef(visibility, name, spec, bindings.unwrap_or_default(), expose),
};

ModDef: raw::Item = {
  <SpannedItem<ModDef_>>,
};

ModImport_: raw::ItemData = {
  "import" <name: ModName> <expose: OptExposeSpec> =>
    raw::ItemData::ModImport(name, expose),
};

ModImport: raw::Item = {
  <SpannedItem<ModImport_>>,
};

ModExpose_: raw::ItemData = {
  "from" <path: ModPath> <expose: ExposeSpec> =>
    raw::ItemData::ModExpose(path, expose),
};

ModExpose: raw::Item = {
  <SpannedItem<ModExpose_>>,
};

ModSpec_: raw::ModSpecData = {
  "file" <path: "StringLit"> =>
    raw::ModSpecData::File(path.split('/').map(|s| s.to_owned()).collect()),

  "{" <Program> "}" => raw::ModSpecData::Inline(<>),
};

ModSpec: raw::ModSpec = {
  <SpannedItem<ModSpec_>>,
};

ModBinding: raw::RawResult<raw::ModBinding> = {
  <lo: @L> <name: ModName> <hi: @R> => {
    let span = Span { lo: ByteIdx(lo), hi: ByteIdx(hi), file };
    let id = meta.push(raw::MetaData { span: Some(span) });
    Ok(raw::ModBinding {
      id,
      name: name.clone(),
      binding: raw::ModPath(id, vec![name]),
    })
  },
  <name: ModName> "=" <binding: ModPath> => {
    let span = Span { lo: ByteIdx(lo), hi: ByteIdx(hi), file };
    let id = meta.push(raw::MetaData { span: Some(span) });
    Ok(raw::ModBinding { id, name, binding }),
  }
};

#[inline]
ModPath: raw::ModPath = {
  <path: (<ModName> ".")*> <last: ModName> => {
    let mut result = path;
    result.push(last);
    raw::ModPath(result)
  }
};

#[inline]
QualPath: raw::ModPath = {
  <(<ModName> ".")*> =>
    raw::ModPath(<>),
};

// Public for use in parsing '--profile' arguments
pub QualName: (raw::ModPath, raw::ValName) = {
  <path: QualPath> <name: ValName> =>
    (path, name),
};

ExposeSpec: raw::ExposeSpec = {
  // TODO: Add support for glob imports

  "expose" "{" <CommaSep<ExposeItem>> "}" =>
    raw::ExposeSpec::Specific(<>),
};

OptExposeSpec: raw::ExposeSpec = {
  <spec: ExposeSpec?> =>
    spec.unwrap_or_else(|| raw::ExposeSpec::Specific(vec![])),
};

ExposeItem: raw::RawResult<raw::ExposeItem> = {
  <visibility: OptPub> <name: ValName> => Ok(raw::ExposeItem::Val(visibility, name)),

  <visibility: OptPub> <name: TypeName> <ctors: ("{" <CommaSep<(OptPub CtorName)>> "}")?> =>
    Ok(raw::ExposeItem::Type(visibility, name, ctors.unwrap_or_default())),

  <visibility: OptPub> "module" <name: ModName> <expose: OptExposeSpec> =>
    Ok(raw::ExposeItem::Mod(visibility, name, expose)),
};

// Types

QualTypeName: (raw::ModPath, raw::TypeName) = {
  <path: QualPath> <name: TypeName> =>
    (path, name)
};

AtomicType_: raw::TypeData = {
  "(" <Types> ")",
  <TypeParam> => raw::TypeData::Var(<>),
  <QualTypeName> => raw::TypeData::App(<>.0, <>.1, Vec::new()),
};

AtomicType: raw::Type = {
  <SpannedType<AtomicType_>>,
};

AppType_: raw::TypeData = {
  <AtomicType>,
  <name: QualTypeName> <args: AtomicType+> =>
    raw::TypeData::App(name.0, name.1, args),
};

AppType: raw::Type = {
  <SpannedType<AppType_>>,
};

FuncType_: raw::TypeData = {
  <AppType>,
  <purity: OptProc> <arg: AppType> "->" <ret: FuncType> =>
    raw::TypeData::Func(purity, arg, ret),
};

FuncType: raw::Type = {
  <SpannedType<FuncType_>>,
};

Type: raw::Type = {
  <FuncType>,
};

Types_: raw::TypeData = {
  <types: CommaSep<Type>> => {
    if types.len() == 1 {
      types.into_iter().next().unwrap()
    } else {
      synax::TypeData::Tuple(types)
    }
  },
};

Types: raw::Type = {
  <SpannedType<Types_>>,
};

// Expressions

AtomicExpr_: raw::ExprData = {
  "(" <Exprs> ")",

  <qual_name: QualName> => {
    let (path, name) = qual_name;
    if path.0.is_empty() {
      raw::ExprData::Var(name)
    } else {
      raw::ExprData::QualName(path, name)
    }
  },

  <path: QualPath> <name: CtorName> => raw::ExprData::Ctor(path, name),

  "[" <CommaSep<Expr>> "]" => raw::ExprData::ArrayLit(<>),

  <"IntLit"> => raw::ExprData::IntLit(<>),

  <"ByteLit"> => raw::ExprData::ByteLit(<>),

  <"FloatLit"> => raw::ExprData::FloatLit(<>),

  <"StringLit"> => raw::ExprData::TextLit(<>),

  <MatchExpr>,

  <IfExpr>,
};

AtomicExpr: raw::Expr = {
  <SpannedExpr<AtomicExpr_>>,
};

MatchExpr_: raw::ExprData = {
  "match" <expr: Expr> "{" <cases: CommaSep<(<Pattern> "->" <Expr>)>> "}" =>
    raw::ExprData::Match(expr, cases),
};

MatchExpr: raw::Expr = {
  <SpannedExpr<MatchExpr_>>,
};

IfExpr_: raw::ExprData = {
  "if" <expr: Expr> "{" <if_block: Expr> "}" "else" <else_if_block: IfExpr> => {
    raw::ExprData::Match(
      expr,
      vec![
        (
          raw::pat(meta, raw::PatternData::Ctor(raw::ModPath(vec![]), raw::CtorName("True".to_string()), None)),
          if_block
        ),
        (
          raw::pat(meta, raw::PatternData::Ctor(raw::ModPath(vec![]), raw::CtorName("False".to_string()), None)),
          else_if_block
        )
      ]
    )
  }
  "if" <expr: Expr> "{" <if_block: Expr> "}" "else" "{" <else_block: Expr> "}" => {
    raw::ExprData::Match(
      expr,
      vec![
        (
          raw::pat(meta, raw::PatternData::Ctor(raw::ModPath(vec![]), raw::CtorName("True".to_string()), None)),
          if_block
        ),
        (
          raw::pat(meta, raw::PatternData::Ctor(raw::ModPath(vec![]), raw::CtorName("False".to_string()), None)),
          else_block
        )
      ]
    )
  }
};

IfExpr: raw::Expr = {
  <SpannedExpr<IfExpr_>>,
};

PureAppExpr_: raw::ExprData = {
  <AtomicExpr>,

  <func: PureAppExpr> <lo: @L> "(" <args: CommaSep<Expr>> ")" <hi: @R> =>
    raw::ExprData::App(Purity::Pure, func, (lo, hi, args)),
};

PureAppExpr: raw::Expr = {
  <SpannedExpr<PureAppExpr_>>,
};

AppExpr_: raw::ExprData = {
  <PureAppExpr>,

  "do" <func: AtomicExpr> <lo: @L> "(" <args: CommaSep<Expr>> ")" <hi: @R> =>
    raw::ExprData::App(Purity::Impure, func, (lo, hi, args)),
};

AppExpr: raw::Expr = {
  <SpannedExpr<AppExpr_>>,
};

PrefixExpr_: raw::ExprData = {
  <AppExpr>,

  "-&" <PrefixExpr> => raw::unop(meta, Intr::NegByte, <>),
  "-" <PrefixExpr> => raw::unop(meta, Intr::NegInt, <>),
  "-." <PrefixExpr> => raw::unop(meta, Intr::NegFloat, <>),
  "!" <PrefixExpr> => raw::unop(meta, Intr::Not, <>),
};

PrefixExpr: raw::Expr = {
  <SpannedExpr<PrefixExpr_>>,
};

ArithProdExpr_: raw::ExprData = {
  <PrefixExpr>,

  <left: ArithProdExpr> "*&" <right: AppExpr> => raw::binop(meta, Intr::MulByte, left, right),
  <left: ArithProdExpr> "/&" <right: AppExpr> => raw::binop(meta, Intr::DivByte, left, right),

  <left: ArithProdExpr> "*" <right: AppExpr> => raw::binop(meta, Intr::MulInt, left, right),
  <left: ArithProdExpr> "/" <right: AppExpr> => raw::binop(meta, Intr::DivInt, left, right),

  <left: ArithProdExpr> "*." <right: AppExpr> => raw::binop(meta, Intr::MulFloat, left, right),
  <left: ArithProdExpr> "/." <right: AppExpr> => raw::binop(meta, Intr::DivFloat, left, right),
};

ArithProdExpr: raw::Expr = {
  <SpannedExpr<ArithProdExpr_>>,
};

ArithSumExpr_: raw::ExprData = {
  <ArithProdExpr>,

  <left: ArithSumExpr> "+&" <right: ArithProdExpr> => raw::binop(meta, Intr::AddByte, left, right),
  <left: ArithSumExpr> "-&" <right: ArithProdExpr> => raw::binop(meta, Intr::SubByte, left, right),

  <left: ArithSumExpr> "+" <right: ArithProdExpr> => raw::binop(meta, Intr::AddInt, left, right),
  <left: ArithSumExpr> "-" <right: ArithProdExpr> => raw::binop(meta, Intr::SubInt, left, right),

  <left: ArithSumExpr> "+." <right: ArithProdExpr> => raw::binop(meta, Intr::AddFloat, left, right),
  <left: ArithSumExpr> "-." <right: ArithProdExpr> => raw::binop(meta, Intr::SubFloat, left, right),
};

ArithSumExpr: raw::Expr = {
  <SpannedExpr<ArithSumExpr_>>,
};

ArithCompExpr_: raw::ExprData = {
  <ArithSumExpr>,

  <left: ArithSumExpr> "=&" <right: ArithSumExpr> => raw::binop(meta, Intr::EqByte, left, right),
  <left: ArithSumExpr> "<&" <right: ArithSumExpr> => raw::binop(meta, Intr::LtByte, left, right),
  <left: ArithSumExpr> "<=&" <right: ArithSumExpr> => raw::binop(meta, Intr::LteByte, left, right),
  <left: ArithSumExpr> ">&" <right: ArithSumExpr> => raw::binop(meta, Intr::GtByte, left, right),
  <left: ArithSumExpr> ">=&" <right: ArithSumExpr> => raw::binop(meta, Intr::GteByte, left, right),

  <left: ArithSumExpr> "=" <right: ArithSumExpr> => raw::binop(meta, Intr::EqInt, left, right),
  <left: ArithSumExpr> "<" <right: ArithSumExpr> => raw::binop(meta, Intr::LtInt, left, right),
  <left: ArithSumExpr> "<=" <right: ArithSumExpr> => raw::binop(meta, Intr::LteInt, left, right),
  <left: ArithSumExpr> ">" <right: ArithSumExpr> => raw::binop(meta, Intr::GtInt, left, right),
  <left: ArithSumExpr> ">=" <right: ArithSumExpr> => raw::binop(meta, Intr::GteInt, left, right),

  <left: ArithSumExpr> "=." <right: ArithSumExpr> => raw::binop(meta, Intr::EqFloat, left, right),
  <left: ArithSumExpr> "<." <right: ArithSumExpr> => raw::binop(meta, Intr::LtFloat, left, right),
  <left: ArithSumExpr> "<=." <right: ArithSumExpr> => raw::binop(meta, Intr::LteFloat, left, right),
  <left: ArithSumExpr> ">." <right: ArithSumExpr> => raw::binop(meta, Intr::GtFloat, left, right),
  <left: ArithSumExpr> ">=." <right: ArithSumExpr> => raw::binop(meta, Intr::GteFloat, left, right),
};

ArithCompExpr: raw::Expr = {
  <SpannedExpr<ArithCompExpr_>>,
};

ArithExpr: raw::Expr = {
  <ArithCompExpr>,
};

AndExpr_: raw::ExprData = {
  <ArithExpr>,

  <left: AndExpr> "&&" <right: ArithExpr> => raw::ExprData::And(left, right),
}

AndExpr: raw::Expr = {
  <SpannedExpr<AndExpr_>>,
}

OrExpr_: raw::ExprData = {
  <AndExpr>,

  <left: OrExpr> "||" <right: AndExpr> => raw::ExprData::Or(left, right),
}

OrExpr: raw::Expr = {
  <SpannedExpr<OrExpr_>>,
}

PipeRightExpr_: raw::ExprData = {
  <OrExpr>,

  <left: PipeRightExpr> "|>" <right: AppExpr> => raw::ExprData::PipeRight(left, right),
}

PipeRightExpr: raw::Expr = {
  <SpannedExpr<PipeRightExpr_>>,
}

BlockExpr_: raw::ExprData = {
  <PipeRightExpr>,

  <left: PipeRightExpr> "<|" <right: BlockExpr> => raw::ExprData::PipeLeft(left, right),

  "let" <lhs: Pattern> "=" <rhs: Expr> "in" <body: BlockExpr> => {
    match body.data {
      // if we already have a LetMany, prepend `lhs = rhs` onto bindings
      raw::ExprData::LetMany(mut bindings, expr) => {
        bindings.push_front((lhs, rhs));
        raw::ExprData::LetMany(bindings, expr)
      },
      // otherwise create a new LetMany
      _ => raw::ExprData::LetMany(vec![(lhs, rhs)].into(), body),
    }
  },

  <rhs: ArithExpr> "then" <body: BlockExpr> => {
    match body.data {
      // if we already have a LetMany, prepend `_ = rhs` onto bindings
      raw::ExprData::LetMany(mut bindings, expr) => {
          bindings.push_front((raw::pat(meta, raw::PatternData::Any), rhs));
          raw::ExprData::LetMany(bindings, expr)
        },
        // otherwise create a new LetMany
      _ => raw::ExprData::LetMany(vec![(raw::pat(meta, raw::PatternData::Any), rhs)].into(), body),
    }
  },

  <purity: OptProc> "\\" <param: Pattern> "->" <body: BlockExpr> =>
    raw::ExprData::Lam(purity, param, body),
};

BlockExpr: raw::Expr = {
  <SpannedExpr<BlockExpr_>>,
};

Expr: raw::Expr = {
  <BlockExpr>,
};

Exprs_: raw::ExprData = {
  <exprs: CommaSep<Expr>> => {
    if exprs.len() == 1 {
      exprs.into_iter().next().unwrap()
    } else {
      raw::ExprData::Tuple(exprs)
    }
  },
};

Exprs: synax::ExprData = {
  <SpannedExpr<Exprs_>>,
}

// Patterns

Pattern_: raw::PatternData = {
  "(" <Patterns> ")",

  "_" => raw::PatternData::Any,

  <ValName> => raw::PatternData::Var(<>),

  <path: QualPath> <ctor: CtorName> =>
    raw::PatternData::Ctor(path, ctor, None),

  <path: QualPath> <ctor: CtorName> "(" <args: Patterns> ")" =>
    raw::PatternData::Ctor(path, ctor, Some(args)),

  <"IntLit"> => raw::PatternData::IntConst(<>),

  <"ByteLit"> => raw::PatternData::ByteConst(<>),

  <"FloatLit"> => raw::PatternData::FloatConst(<>),
};

Pattern: raw::Pattern = {
  <SpannedPattern<Pattern_>>,
};

Patterns_: raw::PatternData = {
  <patterns: CommaSep<Pattern>> => {
    if patterns.len() == 1 {
      patterns.into_iter().next().unwrap()
    } else {
      raw::PatternData::Tuple(patterns)
    }
  }
};

Patterns: raw::Pattern = {
  <SpannedPattern<Patterns_>>,
};
