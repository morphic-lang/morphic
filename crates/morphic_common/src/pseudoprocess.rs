//! This module provides a unified interface for communicating with both in-process threads and
//! external subprocesses.
//!
//! Wrapping threads as if they were subprocesses allows us to test code running under the refernce
//! interpreter using the same framework that we use to test code generated by the LLVM backend.

use crossbeam_channel::{unbounded, Receiver, Sender};
use std::io::{self, BufRead, Cursor, Read, Write};
use std::process;
use std::thread;
use tempfile::TempPath;

#[derive(Debug)]
struct ChannelWriter(Sender<Vec<u8>>);

#[derive(Debug)]
struct ChannelReader {
    curr_chunk: Cursor<Vec<u8>>,
    receiver: Receiver<Vec<u8>>,
}

fn channel_pipe() -> (ChannelWriter, ChannelReader) {
    let (sender, receiver) = unbounded();
    (
        ChannelWriter(sender),
        ChannelReader {
            curr_chunk: Cursor::new(Vec::new()),
            receiver,
        },
    )
}

impl Write for ChannelWriter {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        match self.0.send(buf.to_owned()) {
            Ok(_) => Ok(buf.len()),
            Err(_) => Ok(0),
        }
    }

    fn flush(&mut self) -> io::Result<()> {
        Ok(())
    }
}

impl Read for ChannelReader {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        // Adapted from the source of 'std::io::Cursor::read'
        let n = Read::read(&mut self.fill_buf()?, buf)?;
        self.curr_chunk.consume(n);
        Ok(n)
    }
}

impl BufRead for ChannelReader {
    fn fill_buf(&mut self) -> io::Result<&[u8]> {
        while self.curr_chunk.position() == self.curr_chunk.get_ref().len() as u64 {
            match self.receiver.recv() {
                Ok(next_chunk) => {
                    self.curr_chunk = Cursor::new(next_chunk);
                }
                Err(_) => {
                    self.curr_chunk = Cursor::new(Vec::new());
                    break;
                }
            }
        }

        self.curr_chunk.fill_buf()
    }

    fn consume(&mut self, amt: usize) {
        self.curr_chunk.consume(amt);
    }
}

#[derive(Clone, Copy, Debug)]
pub enum Stdio {
    Inherit,
    Piped,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ExitStatus {
    Success,
    /// For real processes, this corresponds to the return value of std::process::ExitStatus.code()
    Failure(Option<i32>),
}

#[derive(Debug)]
pub enum ChildHandle {
    Thread(thread::JoinHandle<io::Result<ExitStatus>>),
    Process {
        // Currently, generated executables are always written to and executed from temporary files.
        // To make sure the tempfile isn't deleted while the process is running or spawning, we need
        // to keep a reference to it here.
        path: TempPath,
        child: process::Child,
    },
}

pub struct Child {
    pub stdin: Option<Box<dyn Write>>,
    pub stdout: Option<Box<dyn Read>>,
    pub stderr: Option<Box<dyn Read>>,
    handle: ChildHandle,
}

pub fn spawn_thread(
    stdio: Stdio,
    body: impl FnOnce(&mut dyn BufRead, &mut dyn Write, &mut dyn Write) -> io::Result<ExitStatus>
        + Send
        + 'static,
) -> Child {
    match stdio {
        Stdio::Inherit => Child {
            stdin: None,
            stdout: None,
            stderr: None,
            handle: ChildHandle::Thread(thread::spawn(move || {
                body(
                    &mut io::stdin().lock(),
                    &mut io::stdout().lock(),
                    &mut io::stderr().lock(),
                )
            })),
        },
        Stdio::Piped => {
            let (stdin_writer, mut stdin_reader) = channel_pipe();
            let (mut stdout_writer, stdout_reader) = channel_pipe();
            let (mut stderr_writer, stderr_reader) = channel_pipe();
            Child {
                stdin: Some(Box::new(stdin_writer)),
                stdout: Some(Box::new(stdout_reader)),
                stderr: Some(Box::new(stderr_reader)),
                handle: ChildHandle::Thread(thread::spawn(move || {
                    body(&mut stdin_reader, &mut stdout_writer, &mut stderr_writer)
                })),
            }
        }
    }
}

fn check_valgrind() -> io::Result<()> {
    match process::Command::new("valgrind").arg("--version").output() {
        Ok(out) if out.status.success() => Ok(()),
        Ok(_) => Err(io::Error::new(
            io::ErrorKind::Other,
            "valgrind appears to have a problem.  Running 'valgrind --version' failed.",
        )),
        Err(err) if err.kind() == io::ErrorKind::NotFound => Err(io::Error::new(
            io::ErrorKind::NotFound,
            "You don't appear to have valgrind installed in your environment.",
        )),
        Err(err) => Err(err),
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ValgrindConfig {
    /// It is sometimes useful to disable leak checking, such as when you expect the program under
    /// test to exit prematurely due to a runtime error.
    pub leak_check: bool,
}

pub fn spawn_process(
    stdio: Stdio,
    path: TempPath,
    valgrind: Option<ValgrindConfig>,
) -> io::Result<Child> {
    let mut command = if let Some(ValgrindConfig { leak_check }) = valgrind {
        check_valgrind()?;

        let mut command = process::Command::new("valgrind");
        command.arg("--quiet");
        command.arg("--error-exitcode=2");
        if leak_check {
            command.arg("--leak-check=full");
        } else {
            command.arg("--leak-check=no");
        }
        // command.arg("--suppressions=/home/ben/code/morphic/bdwgc.supp");
        command.arg("--").arg(&path);
        command
    } else {
        process::Command::new(&path)
    };

    // let mut command = process::Command::new(&path);

    match stdio {
        Stdio::Inherit => {
            command.stdin(process::Stdio::inherit());
            command.stdout(process::Stdio::inherit());
            command.stderr(process::Stdio::inherit());
        }
        Stdio::Piped => {
            command.stdin(process::Stdio::piped());
            command.stdout(process::Stdio::piped());
            command.stderr(process::Stdio::piped());
        }
    }

    let mut child = command.spawn()?;

    Ok(Child {
        stdin: child
            .stdin
            .take()
            .map(|stdin| Box::new(stdin) as Box<dyn Write>),
        stdout: child
            .stdout
            .take()
            .map(|stdout| Box::new(stdout) as Box<dyn Read>),
        stderr: child
            .stderr
            .take()
            .map(|stderr| Box::new(stderr) as Box<dyn Read>),
        handle: ChildHandle::Process { path, child },
    })
}

impl Child {
    pub fn wait(self) -> io::Result<ExitStatus> {
        match self.handle {
            ChildHandle::Thread(handle) => handle
                .join()
                .unwrap_or_else(|_| panic!("Child thread panicked")),

            ChildHandle::Process {
                path,
                child: mut handle,
            } => {
                let status = handle.wait()?;
                std::mem::drop(path);
                if status.success() {
                    Ok(ExitStatus::Success)
                } else {
                    Ok(ExitStatus::Failure(status.code()))
                }
            }
        }
    }
}
