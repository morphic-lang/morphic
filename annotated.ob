custom type Tree~0 = {_<_> Array (Byte), _<_> Boxed ((Self#0, Self#0))}
custom type Tree~1 = {(Int, _<_> Array (Byte)), _<_> Boxed ((Self#1, Self#1))}
custom type State~0 = Closure~0<...>
custom type State~1 = _<_> Boxed (Self#11)
custom type State~2 = Closure~4<...>
custom type State~3 = Closure~5<...>
custom type State~4 = Closure~6<...>
custom type State~5 = Closure~8<...>
custom type State~6 = Closure~9<...>
custom type State~7 = Closure~11<...>
custom type Closure~0 = ({(Int, _<_> Array (Byte)), _<_> Boxed ((Tree~1<...>, Tree~1<...>))})
custom type Closure~1 = {(State~6<...>, Closure~2<...>), _<_> Boxed ((Self#3, Closure~3<...>))}
custom type Closure~2 = (_<_> Array (Byte))
custom type Closure~3 = ({_<_> Array (Byte), _<_> Boxed ((Tree~0<...>, Tree~0<...>))})
custom type Closure~4 = (Int)
custom type Closure~5 = (Int)
custom type Closure~6 = (State~3<...>, Closure~7<...>)
custom type Closure~7 = (State~2<...>)
custom type Closure~8 = ()
custom type Closure~9 = (State~5<...>, Closure~10<...>)
custom type Closure~10 = ()
custom type Closure~11 = (_<_> Boxed (Closure~1<...>), Closure~12<...>)
custom type Closure~12 = ({(Int, _<_> Array (Byte)), _<_> Boxed ((Tree~1<...>, Tree~1<...>))})
custom type Closure~13 = ()
custom type Closure~14 = ()
custom type Closure~15 = ()
custom type Closure~16 = ()
custom type Closure~17 = ()
custom type Closure~18 = ()
custom type Closure~19 = ()
custom type Closure~20 = ()
custom type Closure~21 = ()
custom type Closure~22 = ()
custom type Closure~23 = ()
custom type Closure~24 = ()
custom type Closure~25 = ()
custom type Closure~26 = ()
custom type Closure~27 = ()
custom type Closure~28 = ()
custom type Closure~29 = ()
custom type Closure~30 = ()
custom type Closure~31 = ()
custom type Closure~32 = ()
custom type Closure~33 = ()
custom type Closure~34 = ()
custom type Closure~35 = ()
custom type Closure~36 = ()
custom type Closure~37 = ()
custom type Closure~38 = ()
custom type Closure~39 = ()
custom type Closure~40 = ()
custom type Closure~41 = ()
custom type Closure~42 = ()
custom type Closure~43 = ()
custom type Closure~44 = ()
custom type Closure~45 = ()
custom type Closure~46 = ()
custom type Closure~47 = ()
custom type Closure~48 = ()
custom type Closure~49 = ()
custom type Closure~50 = ()
custom type Closure~51 = ()
custom type Closure~52 = ()
custom type Closure~53 = ()
custom type Closure~54 = ()
custom type Closure~55 = ()
custom type Closure~56 = _<_> HoleArray (Byte)
custom type Closure~57 = ()

func main_wrapper#0 (%0: ()): () =
let
  0: %1: ()
   = ()
  1: %2: Closure~52<>
   = call main.const#0 (%1 as ())
  2: %3: ()
   = ()
  3: %4: (Closure~52<>, ())
   = (%2 as Closure~52<>, %3 as ())
  4: %5: ()
   = call dispatch#0 (%4 as (Closure~52<>, ()))
in %5 as ()

func dispatch#0 (%0: (Closure~52<>, ())): () =
let
  0: %1: Closure~52<>
   = tuple field 0 %0 as (Closure~52<>, ())
  1: %2: ()
   = tuple field 1 %0 as (Closure~52<>, ())
  2: %3: ()
   = unwrap custom Closure~52 %1 as Closure~52<>
  3: %4: ()
   = call main#0 (%2 as ())
in %4 as ()

func main.const#0 (%0: ()): Closure~52<> =
let
  0: %1: ()
   = ()
  1: %2: Closure~52<>
   = wrap custom Closure~52 %1 as ()
in %2 as Closure~52<>

func main#0 (%0: ()): () =
let
  0...2: %1...%3: Byte = "foo"
  3: %4: ●<{ ↓0 ↓18 ★ }> Array (Byte)
   = [%1...%3]
  4...6: %5...%7: Byte = "bar"
  7: %8: ●<{ ↓0 ↓18 ★ }> Array (Byte)
   = [%5...%7]
  8...10: %9...%11: Byte = "baz"
  11: %12: ●<{ ↓0 ↓18 ★ }> Array (Byte)
   = [%9...%11]
  12...15: %13...%16: Byte = "quux"
  16: %17: ●<{ ↓0 ↓18 ★ }> Array (Byte)
   = [%13...%16]
  17: %18: (●<{ ↓0 ↓18 ★ }> Array (Byte), ●<{ ↓0 ↓18 ★ }> Array (Byte), ●<{ ↓0 ↓18 ★ }> Array (Byte), ●<{ ↓0 ↓18 ★ }> Array (Byte))
   = (%4 as ●<{ ↓0 ↓18 ★ }> Array (Byte), %8 as ●<{ ↓0 ↓18 ★ }> Array (Byte), %12 as ●<{ ↓0 ↓18 ★ }> Array (Byte), %17 as ●<{ ↓0 ↓18 ★ }> Array (Byte))
  18: %19: ()
   = call test#0 (%18 as (●<{ ↓0 ↓18 ★ }> Array (Byte), ●<{ ↓0 ↓18 ★ }> Array (Byte), ●<{ ↓0 ↓18 ★ }> Array (Byte), ●<{ ↓0 ↓18 ★ }> Array (Byte)))
  19...21: %20...%22: Byte = "foo"
  22: %23: ●<{ ↓0 ↓38 ★ }> Array (Byte)
   = [%20...%22]
  23: %24: ●<{ ↓0 ↓38 ★ }> Array (Byte)
   = call force_persistent#0 (%23 as ●<{ ↓0 ↓38 ★ }> Array (Byte))
  24...26: %25...%27: Byte = "bar"
  27: %28: ●<{ ↓0 ↓38 ★ }> Array (Byte)
   = [%25...%27]
  28...30: %29...%31: Byte = "baz"
  31: %32: ●<{ ↓0 ↓38 ★ }> Array (Byte)
   = [%29...%31]
  32...35: %33...%36: Byte = "quux"
  36: %37: ●<{ ↓0 ↓38 ★ }> Array (Byte)
   = [%33...%36]
  37: %38: (●<{ ↓0 ↓38 ★ }> Array (Byte), ●<{ ↓0 ↓38 ★ }> Array (Byte), ●<{ ↓0 ↓38 ★ }> Array (Byte), ●<{ ↓0 ↓38 ★ }> Array (Byte))
   = (%24 as ●<{ ↓0 ↓38 ★ }> Array (Byte), %28 as ●<{ ↓0 ↓38 ★ }> Array (Byte), %32 as ●<{ ↓0 ↓38 ★ }> Array (Byte), %37 as ●<{ ↓0 ↓38 ★ }> Array (Byte))
  38: %39: ()
   = call test#0 (%38 as (●<{ ↓0 ↓38 ★ }> Array (Byte), ●<{ ↓0 ↓38 ★ }> Array (Byte), ●<{ ↓0 ↓38 ★ }> Array (Byte), ●<{ ↓0 ↓38 ★ }> Array (Byte)))
in %39 as ()

func test#0 (%0: (●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓68 ★ }> Array (Byte))): () =
let
  0: %1: ●<{ ↓0 ↓68 ★ }> Array (Byte)
   = tuple field 0 %0 as (●<{ ↓0 ↓68 ★ }> Array (Byte), &<∅> Array (Byte), &<∅> Array (Byte), &<∅> Array (Byte))
  1: %2: ●<{ ↓0 ↓68 ★ }> Array (Byte)
   = tuple field 1 %0 as (&<∅> Array (Byte), ●<{ ↓0 ↓68 ★ }> Array (Byte), &<∅> Array (Byte), &<∅> Array (Byte))
  2: %3: ●<{ ↓0 ↓68 ★ }> Array (Byte)
   = tuple field 2 %0 as (&<∅> Array (Byte), &<∅> Array (Byte), ●<{ ↓0 ↓68 ★ }> Array (Byte), &<∅> Array (Byte))
  3: %4: ●<{ ↓0 ↓68 ★ }> Array (Byte)
   = tuple field 3 %0 as (&<∅> Array (Byte), &<∅> Array (Byte), &<∅> Array (Byte), ●<{ ↓0 ↓68 ★ }> Array (Byte))
  4: %5: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 0 %1 as ●<{ ↓0 ↓68 ★ }> Array (Byte)
  5: %6: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %5 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  6: %7: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 0 %2 as ●<{ ↓0 ↓68 ★ }> Array (Byte)
  7: %8: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %7 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  8: %9: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 0 %3 as ●<{ ↓0 ↓68 ★ }> Array (Byte)
  9: %10: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %9 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  10: %11: ({●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
   = (%8 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, %10 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  11: %12: ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))
   = wrap boxed %11 as ({●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  12: %13: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 1 %12 as ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))
  13: %14: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %13 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  14: %15: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 0 %4 as ●<{ ↓0 ↓68 ★ }> Array (Byte)
  15: %16: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %15 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  16: %17: ({●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
   = (%14 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, %16 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  17: %18: ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))
   = wrap boxed %17 as ({●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  18: %19: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 1 %18 as ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))
  19: %20: {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %19 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  20: %21: ({●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
   = (%6 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, %20 as {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  21: %22: ●<{ ↓0 ↓44 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))
   = wrap boxed %21 as ({●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●<{ ↓0 ↓68 ★ }> Array (Byte), ●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  22: %23: {●<{ ↓0 ↓68 ★ }> Array (Byte), &<{ ↓0 ↓44 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
   = wrap variant 1 %22 as &<{ ↓0 ↓44 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))
  23: %24: {●<{ ↓0 ↓68 ★ }> Array (Byte), &<{ ↓0 ↓44 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}
   = wrap custom Tree~0 %23 as {●<{ ↓0 ↓68 ★ }> Array (Byte), &<{ ↓0 ↓44 ★ }> Boxed (({●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}, {●@●<{ ↓0 ↓68 ★ }> Array (Byte), ●@●<{ ↓0 ↓47 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))}))}
  24...37: %25...%38: Byte = "Original tree:"
  38: %39: ●<{ ↓0 ↓39 ★ }> Array (Byte)
   = [%25...%38]
  39: %40: ()
   = call writeln#0 (%39 as &<{ ↓0 ↓39 ★ }> Array (Byte))
  40: %41: ()
   = ()
  41: %42: Closure~53<>
   = wrap custom Closure~53 %41 as ()
  42: %43: (Closure~53<>, {&<{ ↓0 ↓43 ★ }> Array (Byte), &<{ ↓0 ↓43 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓43 ★ }>, ●@●<{ ↓0 ↓43 ★ }>>, Tree~0<●@●<{ ↓0 ↓43 ★ }>, ●@●<{ ↓0 ↓43 ★ }>>))})
   = (%42 as Closure~53<>, %24 as {&<{ ↓0 ↓43 ★ }> Array (Byte), &<{ ↓0 ↓43 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓43 ★ }>, ●@●<{ ↓0 ↓43 ★ }>>, Tree~0<●@●<{ ↓0 ↓43 ★ }>, ●@●<{ ↓0 ↓43 ★ }>>))})
  43: %44: ()
   = call print_tree#1 (%43 as (Closure~53<>, {&<{ ↓0 ↓43 ★ }> Array (Byte), &<{ ↓0 ↓43 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓43 ★ }>, ●@●<{ ↓0 ↓43 ★ }>>, Tree~0<●@●<{ ↓0 ↓43 ★ }>, ●@●<{ ↓0 ↓43 ★ }>>))}))
  44: %45: ●<{ ↓0 ↓47 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>)
   = call index_leaves#0 (%24 as {●<{ ↓0 ↓68 ★ }> Array (Byte), &<{ ↓0 ↓44 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>, Tree~0<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>))})
  45: %46: Int
   = 0
  46: %47: (&<{ ↓0 ↓47 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>), Int)
   = (%45 as &<{ ↓0 ↓47 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>), %46 as Int)
  47: %48: (Int, {(Int, ●<{ ↓0 ↓68 ★ }> Array (Byte)), ●<{ ↓0 ↓68 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>, Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>))})
   = call run#0 (%47 as (&<{ ↓0 ↓47 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>, ●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓47 ★ }>>), Int))
  48: %49: Int
   = tuple field 0 %48 as (Int, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  49: %50: {(Int, &<{ ↓0 ↓68 ★ }> Array (Byte)), &<{ ↓0 ↓68 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>, Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>))}
   = tuple field 1 %48 as (Int, {(Int, &<{ ↓0 ↓68 ★ }> Array (Byte)), &<{ ↓0 ↓68 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>, Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>))})
  50...62: %51...%63: Byte = "Indexed tree:"
  63: %64: ●<{ ↓0 ↓64 ★ }> Array (Byte)
   = [%51...%63]
  64: %65: ()
   = call writeln#0 (%64 as &<{ ↓0 ↓64 ★ }> Array (Byte))
  65: %66: ()
   = ()
  66: %67: Closure~54<>
   = wrap custom Closure~54 %66 as ()
  67: %68: (Closure~54<>, {(Int, &<{ ↓0 ↓68 ★ }> Array (Byte)), &<{ ↓0 ↓68 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>, Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>))})
   = (%67 as Closure~54<>, %50 as {(Int, &<{ ↓0 ↓68 ★ }> Array (Byte)), &<{ ↓0 ↓68 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>, Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>))})
  68: %69: ()
   = call print_tree#0 (%68 as (Closure~54<>, {(Int, &<{ ↓0 ↓68 ★ }> Array (Byte)), &<{ ↓0 ↓68 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>, Tree~1<●@●<{ ↓0 ↓68 ★ }>, ●@●<{ ↓0 ↓68 ★ }>>))}))
in %69 as ()

func force_persistent#0 (%0: ●<'0> Array (Byte)): ●<'0> Array (Byte) =
let
  0: %1: Bool
   = False
  // guard_types: lowered from condition 'True'
  1: %2: ●<'0> Array (Byte)
   = if %1 as Bool {
    let
      0: %2: ()
       = ()
      1: %3: Closure~57<>
       = wrap custom Closure~57 %2 as ()
      2: %4: Int
       = 0
      3: %5: (●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }> Array (Byte), Int)
       = (%0 as ●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }> Array (Byte), %4 as Int)
      4: %6: (Closure~57<>, (●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }> Array (Byte), Int))
       = (%3 as Closure~57<>, %5 as (●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }> Array (Byte), Int))
      5: %7: (Byte, Closure~56<●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }>>)
       = call dispatch#2 (%6 as (Closure~57<>, (●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }> Array (Byte), Int)))
      6: %8: Byte
       = tuple field 0 %7 as (Byte, Closure~56<&<∅>>)
      7: %9: Closure~56<●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }>>
       = tuple field 1 %7 as (Byte, Closure~56<●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }>>)
      8: %10: (Closure~56<●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }>>, Byte)
       = (%9 as Closure~56<●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }>>, %8 as Byte)
      9: %11: ●<∅> Array (Byte)
       = call dispatch#1 (%10 as (Closure~56<●<{ ↓0 ↓1 ↓1 (↓9 ★ ‖ -) }>>, Byte))
    in %0 as ●<'0> Array (Byte)
  } else {
    let
      0: %2: Bool
       = if %1 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %3: ●<'0> Array (Byte)
       = if %2 as Bool {
        let
        in %0 as ●<'0> Array (Byte)
      } else {
        let
          0: %3: ●<'0> Array (Byte)
           = unreachable
        in %3 as ●<'0> Array (Byte)
      }
    in %3 as ●<'0> Array (Byte)
  }
in %2 as ●<'0> Array (Byte)

func print_tree#0 (%0: (Closure~54<>, {(Int, &<{ ↓0 ↓4 ★ }> Array (Byte)), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))})): () =
let
  0: %1: Closure~54<>
   = tuple field 0 %0 as (Closure~54<>, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  1: %2: {(Int, &<{ ↓0 ↓4 ★ }> Array (Byte)), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}
   = tuple field 1 %0 as (Closure~54<>, {(Int, &<{ ↓0 ↓4 ★ }> Array (Byte)), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))})
  2: %3: Int
   = 0
  3: %4: (Closure~54<>, {(Int, &<{ ↓0 ↓4 ★ }> Array (Byte)), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}, Int)
   = (%1 as Closure~54<>, %2 as {(Int, &<{ ↓0 ↓4 ★ }> Array (Byte)), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}, %3 as Int)
  4: %5: ()
   = call print_tree_rec#0 (%4 as (Closure~54<>, {(Int, &<{ ↓0 ↓4 ★ }> Array (Byte)), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}, Int))
  5: %6: Byte
   = '\n'
  6: %7: ●<{ ↓0 ↓7 ★ }> Array (Byte)
   = [%6]
  7: %8: ()
   = output(%7 as &<{ ↓0 ↓7 ★ }> Array (Byte))
in %8 as ()

func writeln#0 (%0: &<{ ↓0 ↓0 ★ }> Array (Byte)): () =
let
  0: %1: ()
   = output(%0 as &<{ ↓0 ↓0 ★ }> Array (Byte))
  1: %2: Byte
   = '\n'
  2: %3: ●<{ ↓0 ↓3 ★ }> Array (Byte)
   = [%2]
  3: %4: ()
   = output(%3 as &<{ ↓0 ↓3 ★ }> Array (Byte))
in %4 as ()

func run#0 (%0: (&<{ ↓0 ↓3 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'0 ⨆ '2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>>), Int)): (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}) =
let
  0: %1: &<{ ↓0 ↓3 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'0 ⨆ '2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>>)
   = tuple field 0 %0 as (&<{ ↓0 ↓3 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'0 ⨆ '2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>>), Int)
  1: %2: Int
   = tuple field 1 %0 as (&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Int)
  2: %3: &<{ ↓0 ↓3 ★ }> Boxed ({(State~6<>, Closure~2<●@●<'0>>), ●@●<{ ↓0 ↓5 ★ }> Boxed ((State~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>>, Closure~3<●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>>))})
   = unwrap custom State~1 %1 as &<{ ↓0 ↓3 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'0 ⨆ '2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2 ⨆ '4>, ●@●<{ ↓0 ↓5 ★ }>>)
  3: %4: {(State~6<>, Closure~2<●<'0>>), ●<{ ↓0 ↓5 ★ }> Boxed ((State~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>>, Closure~3<●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>>))}
   = unwrap boxed %3 as &<{ ↓0 ↓3 ★ }> Boxed ({(State~6<>, Closure~2<●@●<'0>>), ●@●<{ ↓0 ↓5 ★ }> Boxed ((State~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>>, Closure~3<●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>>))})
  4: %5: ({(State~6<>, Closure~2<●<'0>>), &<{ ↓0 ↓5 ★ }> Boxed ((State~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>>, Closure~3<●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>>))}, Int)
   = (%4 as {(State~6<>, Closure~2<●<'0>>), &<{ ↓0 ↓5 ★ }> Boxed ((State~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>>, Closure~3<●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>>))}, %2 as Int)
  5: %6: (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = call dispatch#3 (%5 as ({(State~6<>, Closure~2<●<'0>>), &<{ ↓0 ↓5 ★ }> Boxed ((State~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'2>, ●@●<{ ↓0 ↓5 ★ }>>, Closure~3<●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'4>, ●@●<{ ↓0 ↓5 ★ }>>))}, Int))
in %6 as (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})

func index_leaves#0 (%0: {●<'2> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}): ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>) =
let
  0: %1: {&<∅> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
   = unwrap custom Tree~0 %0 as {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
  1: %2: Bool
   = check variant 0 %1 as {&<∅> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
  2: %3: Bool
   = if %2 as Bool {
    let
      0: %3: &<∅> Array (Byte)
       = unwrap variant 0 %1 as {&<∅> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
      1: %4: Bool
       = True
    in %4 as Bool
  } else {
    False
  }
  // guard_types: lowered from condition 'custom #0 (variant 0 (_))'
  3: %4: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = if %3 as Bool {
    let
      0: %4: {●<'2> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
       = unwrap custom Tree~0 %0 as {●<'2> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
      1: %5: ●<'2> Array (Byte)
       = unwrap variant 0 %4 as {●<'2> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
      2: %6: ()
       = ()
      3: %7: State~6<>
       = call inc.const#0 (%6 as ())
      4: %8: (●<'2> Array (Byte))
       = (%5 as ●<'2> Array (Byte))
      5: %9: Closure~2<●<'2>>
       = wrap custom Closure~2 %8 as (●<'2> Array (Byte))
      6: %10: (State~6<>, Closure~2<●<'2>>)
       = (%7 as State~6<>, %9 as Closure~2<●<'2>>)
      7: %11: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
       = call bind#1 (%10 as (State~6<>, Closure~2<●<'2>>))
    in %11 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
  } else {
    let
      0: %4: {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
       = unwrap custom Tree~0 %0 as {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
      1: %5: Bool
       = check variant 1 %4 as {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
      2: %6: Bool
       = if %5 as Bool {
        let
          0: %6: &<{ ↓0 ↓3 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))
           = unwrap variant 1 %4 as {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
          1: %7: ({●<∅> Array (Byte), ●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●<∅> Array (Byte), ●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
           = unwrap boxed %6 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))
          2: %8: {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
           = tuple field 0 %7 as ({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
          3: %9: Bool
           = True
          4: %10: {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
           = tuple field 1 %7 as ({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
          5: %11: Bool
           = True
          6: %12: Bool
           = if %9 as Bool {
            if %11 as Bool {
              True
            } else {
              False
            }
          } else {
            False
          }
        in %12 as Bool
      } else {
        False
      }
      // guard_types: lowered from condition 'custom #0 (variant 1 (boxed ((_, _))))'
      3: %7: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
       = if %6 as Bool {
        let
          0: %7: {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<'2> Array (Byte), ●@●<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}, {●@●<'4> Array (Byte), ●@●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))}))}
           = unwrap custom Tree~0 %0 as {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}
          1: %8: &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<'2> Array (Byte), ●@●<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}, {●@●<'4> Array (Byte), ●@●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))}))
           = unwrap variant 1 %7 as {&<∅> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<'2> Array (Byte), ●@●<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}, {●@●<'4> Array (Byte), ●@●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))}))}
          2: %9: ({●<'2> Array (Byte), ●<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}, {●<'4> Array (Byte), ●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))})
           = unwrap boxed %8 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<'2> Array (Byte), ●@●<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}, {●@●<'4> Array (Byte), ●@●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))}))
          3: %10: {●<'2> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}
           = tuple field 0 %9 as ({●<'2> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
          4: %11: {●<'4> Array (Byte), ●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))}
           = tuple field 1 %9 as ({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●<'4> Array (Byte), ●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))})
          5: %12: ●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
           = call index_leaves#0 (%10 as {●<'2> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓3 ↓1 (↓5 ★ ‖ -)) }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))})
          6: %13: ({●<'4> Array (Byte), ●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))})
           = (%11 as {●<'4> Array (Byte), ●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))})
          7: %14: Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>
           = wrap custom Closure~3 %13 as ({●<'4> Array (Byte), ●<'5> Boxed ((Tree~0<●@●<'6>, ●@●<'7>>, Tree~0<●@●<'8>, ●@●<'9>>))})
          8: %15: (●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
           = (%12 as ●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), %14 as Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
          9: %16: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
           = call bind#0 (%15 as (●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))
        in %16 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
      } else {
        let
          0: %7: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
           = unreachable
        in %7 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
      }
    in %7 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
  }
in %4 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)

func print_tree#1 (%0: (Closure~53<>, {&<{ ↓0 ↓4 ★ }> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))})): () =
let
  0: %1: Closure~53<>
   = tuple field 0 %0 as (Closure~53<>, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
  1: %2: {&<{ ↓0 ↓4 ★ }> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}
   = tuple field 1 %0 as (Closure~53<>, {&<{ ↓0 ↓4 ★ }> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))})
  2: %3: Int
   = 0
  3: %4: (Closure~53<>, {&<{ ↓0 ↓4 ★ }> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}, Int)
   = (%1 as Closure~53<>, %2 as {&<{ ↓0 ↓4 ★ }> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}, %3 as Int)
  4: %5: ()
   = call print_tree_rec#1 (%4 as (Closure~53<>, {&<{ ↓0 ↓4 ★ }> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>, Tree~0<●@●<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>>))}, Int))
  5: %6: Byte
   = '\n'
  6: %7: ●<{ ↓0 ↓7 ★ }> Array (Byte)
   = [%6]
  7: %8: ()
   = output(%7 as &<{ ↓0 ↓7 ★ }> Array (Byte))
in %8 as ()

func dispatch#1 (%0: (Closure~56<●<'0>>, Byte)): ●<'0> Array (Byte) =
let
  0: %1: Closure~56<●<'0>>
   = tuple field 0 %0 as (Closure~56<●<'0>>, Byte)
  1: %2: Byte
   = tuple field 1 %0 as (Closure~56<&<∅>>, Byte)
  2: %3: ●<'0> HoleArray (Byte)
   = unwrap custom Closure~56 %1 as Closure~56<●<'0>>
  3: %4: ●<'0> Array (Byte)
   = replace(%3 as ●<'0> HoleArray (Byte), %2 as Byte)
in %4 as ●<'0> Array (Byte)

func dispatch#2 (%0: (Closure~57<>, (●<'0> Array (Byte), Int))): (Byte, Closure~56<●<'0>>) =
let
  0: %1: Closure~57<>
   = tuple field 0 %0 as (Closure~57<>, (&<∅> Array (Byte), Int))
  1: %2: (●<'0> Array (Byte), Int)
   = tuple field 1 %0 as (Closure~57<>, (●<'0> Array (Byte), Int))
  2: %3: ()
   = unwrap custom Closure~57 %1 as Closure~57<>
  3: %4: ●<'0> Array (Byte)
   = tuple field 0 %2 as (●<'0> Array (Byte), Int)
  4: %5: Int
   = tuple field 1 %2 as (&<∅> Array (Byte), Int)
  5: %6: (Byte, ●<'0> HoleArray (Byte))
   = extract(%4 as ●<'0> Array (Byte), %5 as Int)
  6: %7: Byte
   = tuple field 0 %6 as (Byte, &<∅> HoleArray (Byte))
  7: %8: ●<'0> HoleArray (Byte)
   = tuple field 1 %6 as (Byte, ●<'0> HoleArray (Byte))
  8: %9: Closure~56<●<'0>>
   = wrap custom Closure~56 %8 as ●<'0> HoleArray (Byte)
  9: %10: (Byte, Closure~56<●<'0>>)
   = (%7 as Byte, %9 as Closure~56<●<'0>>)
in %10 as (Byte, Closure~56<●<'0>>)

func print_tree_rec#0 (%0: (Closure~54<>, {(Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int)): () =
let
  0: %1: Closure~54<>
   = tuple field 0 %0 as (Closure~54<>, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, Int)
  1: %2: {(Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}
   = tuple field 1 %0 as (Closure~54<>, {(Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int)
  2: %3: Int
   = tuple field 2 %0 as (Closure~54<>, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, Int)
  3: %4: {(Int, &<∅> Array (Byte)), &<∅> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
   = unwrap custom Tree~1 %2 as {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}
  4: %5: Bool
   = check variant 0 %4 as {(Int, &<∅> Array (Byte)), &<∅> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
  5: %6: Bool
   = if %5 as Bool {
    let
      0: %6: (Int, &<∅> Array (Byte))
       = unwrap variant 0 %4 as {(Int, &<∅> Array (Byte)), &<∅> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
      1: %7: Bool
       = True
    in %7 as Bool
  } else {
    False
  }
  // guard_types: lowered from condition 'custom #1 (variant 0 (_))'
  6: %7: ()
   = if %6 as Bool {
    let
      0: %7: {(Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)), &<∅> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
       = unwrap custom Tree~1 %2 as {(Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}
      1: %8: (Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte))
       = unwrap variant 0 %7 as {(Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)), &<∅> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
      2...6: %9...%13: Byte = "Leaf("
      7: %14: ●<{ ↓0 ↓6 ↓1 (↓8 ★ ‖ -) }> Array (Byte)
       = [%9...%13]
      8: %15: ()
       = output(%14 as &<{ ↓0 ↓6 ↓1 (↓8 ★ ‖ -) }> Array (Byte))
      9: %16: ()
       = call test#1 (%8 as (Int, &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)))
      10: %17: Byte
       = ')'
      11: %18: ●<{ ↓0 ↓6 ↓1 (↓12 ★ ‖ -) }> Array (Byte)
       = [%17]
      12: %19: ()
       = output(%18 as &<{ ↓0 ↓6 ↓1 (↓12 ★ ‖ -) }> Array (Byte))
    in %19 as ()
  } else {
    let
      0: %7: {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
       = unwrap custom Tree~1 %2 as {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}
      1: %8: Bool
       = check variant 1 %7 as {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
      2: %9: Bool
       = if %8 as Bool {
        let
          0: %9: &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))
           = unwrap variant 1 %7 as {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))}
          1: %10: ({(Int, ●<∅> Array (Byte)), ●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●<∅> Array (Byte)), ●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
           = unwrap boxed %9 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, ●@●<∅> Array (Byte)), ●@●<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}))
          2: %11: {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}
           = tuple field 0 %10 as ({(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
          3: %12: Bool
           = True
          4: %13: {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}
           = tuple field 1 %10 as ({(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
          5: %14: Bool
           = True
          6: %15: Bool
           = if %12 as Bool {
            if %14 as Bool {
              True
            } else {
              False
            }
          } else {
            False
          }
        in %15 as Bool
      } else {
        False
      }
      // guard_types: lowered from condition 'custom #1 (variant 1 (boxed ((_, _))))'
      3: %10: ()
       = if %9 as Bool {
        let
          0: %10: {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))}
           = unwrap custom Tree~1 %2 as {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}
          1: %11: &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))
           = unwrap variant 1 %10 as {(Int, &<∅> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))}
          2: %12: ({(Int, ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {(Int, ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))})
           = unwrap boxed %11 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {(Int, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))
          3: %13: {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}
           = tuple field 0 %12 as ({(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
          4: %14: {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}
           = tuple field 1 %12 as ({(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}, {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))})
          5...12: %15...%22: Byte = "Branch(\n"
          13: %23: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓14 ★ ‖ -)) }> Array (Byte)
           = [%15...%22]
          14: %24: ()
           = output(%23 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓14 ★ ‖ -)) }> Array (Byte))
          15: %25: Int
           = 1
          16: %26: (Int, Int)
           = (%3 as Int, %25 as Int)
          17: %27: Int
           = add_int %26 as (Int, Int)
          18: %28: ()
           = call print_indent#2 (%27 as Int)
          19: %29: Int
           = 1
          20: %30: (Int, Int)
           = (%3 as Int, %29 as Int)
          21: %31: Int
           = add_int %30 as (Int, Int)
          22: %32: (Closure~54<>, {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, Int)
           = (%1 as Closure~54<>, %13 as {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, %31 as Int)
          23: %33: ()
           = call print_tree_rec#0 (%32 as (Closure~54<>, {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, Int))
          24...25: %34...%35: Byte = ",\n"
          26: %36: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓27 ★ ‖ -)) }> Array (Byte)
           = [%34...%35]
          27: %37: ()
           = output(%36 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓27 ★ ‖ -)) }> Array (Byte))
          28: %38: Int
           = 1
          29: %39: (Int, Int)
           = (%3 as Int, %38 as Int)
          30: %40: Int
           = add_int %39 as (Int, Int)
          31: %41: ()
           = call print_indent#1 (%40 as Int)
          32: %42: Int
           = 1
          33: %43: (Int, Int)
           = (%3 as Int, %42 as Int)
          34: %44: Int
           = add_int %43 as (Int, Int)
          35: %45: (Closure~54<>, {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int)
           = (%1 as Closure~54<>, %14 as {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, %44 as Int)
          36: %46: ()
           = call print_tree_rec#0 (%45 as (Closure~54<>, {(Int, &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte)), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~1<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int))
          37: %47: Byte
           = '\n'
          38: %48: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓39 ★ ‖ -)) }> Array (Byte)
           = [%47]
          39: %49: ()
           = output(%48 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓39 ★ ‖ -)) }> Array (Byte))
          40: %50: ()
           = call print_indent#0 (%3 as Int)
          41: %51: Byte
           = ')'
          42: %52: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓43 ★ ‖ -)) }> Array (Byte)
           = [%51]
          43: %53: ()
           = output(%52 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓43 ★ ‖ -)) }> Array (Byte))
        in %53 as ()
      } else {
        let
          0: %10: ()
           = unreachable
        in %10 as ()
      }
    in %10 as ()
  }
in %7 as ()

func dispatch#3 (%0: ({(State~6<>, Closure~2<●<'6>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((State~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>, Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))}, Int)): (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))}) =
let
  0: %1: {(State~6<>, Closure~2<●<'6>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((State~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>, Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))}
   = tuple field 0 %0 as ({(State~6<>, Closure~2<●<'6>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((State~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>, Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))}, Int)
  1: %2: Int
   = tuple field 1 %0 as ({(State~6<>, Closure~2<&<∅>>), &<∅> Boxed ((State~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}, Int)
  2: %3: {(State~6<>, Closure~2<&<∅>>), &<∅> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
   = unwrap custom Closure~1 %1 as {(State~6<>, Closure~2<&<∅>>), &<∅> Boxed ((State~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
  3: %4: Bool
   = check variant 0 %3 as {(State~6<>, Closure~2<&<∅>>), &<∅> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
  4: %5: Bool
   = if %4 as Bool {
    let
      0: %5: (State~6<>, Closure~2<&<∅>>)
       = unwrap variant 0 %3 as {(State~6<>, Closure~2<&<∅>>), &<∅> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
      1: %6: Bool
       = True
    in %6 as Bool
  } else {
    False
  }
  // guard_types: lowered from condition 'custom #11 (variant 0 (_))'
  5: %6: (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
   = if %5 as Bool {
    let
      0: %6: {(State~6<>, Closure~2<●<'6>>), &<∅> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
       = unwrap custom Closure~1 %1 as {(State~6<>, Closure~2<●<'6>>), &<∅> Boxed ((State~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
      1: %7: (State~6<>, Closure~2<●<'6>>)
       = unwrap variant 0 %6 as {(State~6<>, Closure~2<●<'6>>), &<∅> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
      2: %8: ((State~6<>, Closure~2<●<'6>>), Int)
       = (%7 as (State~6<>, Closure~2<●<'6>>), %2 as Int)
      3: %9: (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
       = call bind#3 (%8 as ((State~6<>, Closure~2<●<'6>>), Int))
    in %9 as (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
  } else {
    let
      0: %6: {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
       = unwrap custom Closure~1 %1 as {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((State~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
      1: %7: Bool
       = check variant 1 %6 as {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
      2: %8: Bool
       = if %7 as Bool {
        let
          0: %8: &<{ ↓0 ↓5 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))
           = unwrap variant 1 %6 as {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))}
          1: %9: (●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●<∅>, ●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>)
           = unwrap boxed %8 as &<{ ↓0 ↓5 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((●@●<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>))
          2: %10: Bool
           = True
        in %10 as Bool
      } else {
        False
      }
      // guard_types: lowered from condition 'custom #11 (variant 1 (boxed (_)))'
      3: %9: (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
       = if %8 as Bool {
        let
          0: %9: {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))}
           = unwrap custom Closure~1 %1 as {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((State~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>, Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))}
          1: %10: &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))
           = unwrap variant 1 %9 as {(State~6<>, Closure~2<&<∅>>), &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))}
          2: %11: (●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●<'10>, ●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>)
           = unwrap boxed %10 as &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>))
          3: %12: ((&<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●<'10>, &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Int)
           = (%11 as (&<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●<'10>, &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), %2 as Int)
          4: %13: (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
           = call bind#2 (%12 as ((&<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'8>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Closure~3<●<'10>, &<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>, ●@●<'10>, ●@●<{ ↓0 ↓5 ↓1 (- ‖ ↓3 ↓1 (↓4 ★ ‖ -)) }>>), Int))
        in %13 as (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
      } else {
        let
          0: %9: (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
           = unreachable
        in %9 as (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
      }
    in %9 as (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})
  }
in %6 as (Int, {(Int, ●<'6> Array (Byte)), ●<'7> Boxed ((Tree~1<●@●<'8>, ●@●<'9>>, Tree~1<●@●<'10>, ●@●<'11>>))})

func bind#0 (%0: (●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)): ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>) =
let
  0: %1: ●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = tuple field 0 %0 as (●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>)
  1: %2: Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>
   = tuple field 1 %0 as (&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
  2: %3: (●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = (%1 as ●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), %2 as Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
  3: %4: ●<'3> Boxed ((●@●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))
   = wrap boxed %3 as (●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●<'4>, ●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
  4: %5: {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((●@●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
   = wrap variant 1 %4 as ●<'3> Boxed ((●@●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))
  5: %6: {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
   = wrap custom Closure~1 %5 as {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((●@●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
  6: %7: ●<'0> Boxed ({(State~6<>, Closure~2<●@●<'2>>), ●@●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))})
   = wrap boxed %6 as {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
  7: %8: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = wrap custom State~1 %7 as ●<'0> Boxed ({(State~6<>, Closure~2<●@●<'2>>), ●@●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))})
in %8 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)

func bind#1 (%0: (State~6<>, Closure~2<●<'2>>)): ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>) =
let
  0: %1: State~6<>
   = tuple field 0 %0 as (State~6<>, Closure~2<&<∅>>)
  1: %2: Closure~2<●<'2>>
   = tuple field 1 %0 as (State~6<>, Closure~2<●<'2>>)
  2: %3: (State~6<>, Closure~2<●<'2>>)
   = (%1 as State~6<>, %2 as Closure~2<●<'2>>)
  3: %4: {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((●@●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
   = wrap variant 0 %3 as (State~6<>, Closure~2<●<'2>>)
  4: %5: {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
   = wrap custom Closure~1 %4 as {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((●@●<'1> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
  5: %6: ●<'0> Boxed ({(State~6<>, Closure~2<●@●<'2>>), ●@●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))})
   = wrap boxed %5 as {(State~6<>, Closure~2<●<'2>>), ●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))}
  6: %7: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = wrap custom State~1 %6 as ●<'0> Boxed ({(State~6<>, Closure~2<●@●<'2>>), ●@●<'3> Boxed ((State~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>, Closure~3<●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>))})
in %7 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)

func inc.const#0 (%0: ()): State~6<> =
let
  0: %1: ()
   = ()
  1: %2: State~5<>
   = call get.const#0 (%1 as ())
  2: %3: ()
   = ()
  3: %4: Closure~10<>
   = wrap custom Closure~10 %3 as ()
  4: %5: (State~5<>, Closure~10<>)
   = (%2 as State~5<>, %4 as Closure~10<>)
  5: %6: State~6<>
   = call bind#4 (%5 as (State~5<>, Closure~10<>))
in %6 as State~6<>

func print_tree_rec#1 (%0: (Closure~53<>, {&<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int)): () =
let
  0: %1: Closure~53<>
   = tuple field 0 %0 as (Closure~53<>, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, Int)
  1: %2: {&<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}
   = tuple field 1 %0 as (Closure~53<>, {&<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int)
  2: %3: Int
   = tuple field 2 %0 as (Closure~53<>, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, Int)
  3: %4: {&<∅> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
   = unwrap custom Tree~0 %2 as {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
  4: %5: Bool
   = check variant 0 %4 as {&<∅> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
  5: %6: Bool
   = if %5 as Bool {
    let
      0: %6: &<∅> Array (Byte)
       = unwrap variant 0 %4 as {&<∅> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
      1: %7: Bool
       = True
    in %7 as Bool
  } else {
    False
  }
  // guard_types: lowered from condition 'custom #0 (variant 0 (_))'
  6: %7: ()
   = if %6 as Bool {
    let
      0: %7: {&<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
       = unwrap custom Tree~0 %2 as {&<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
      1: %8: &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte)
       = unwrap variant 0 %7 as {&<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte), &<∅> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
      2...6: %9...%13: Byte = "Leaf("
      7: %14: ●<{ ↓0 ↓6 ↓1 (↓8 ★ ‖ -) }> Array (Byte)
       = [%9...%13]
      8: %15: ()
       = output(%14 as &<{ ↓0 ↓6 ↓1 (↓8 ★ ‖ -) }> Array (Byte))
      9: %16: ()
       = output(%8 as &<{ ↓0 ↓6 ↓1 (↓9 ★ ‖ -) }> Array (Byte))
      10: %17: Byte
       = ')'
      11: %18: ●<{ ↓0 ↓6 ↓1 (↓12 ★ ‖ -) }> Array (Byte)
       = [%17]
      12: %19: ()
       = output(%18 as &<{ ↓0 ↓6 ↓1 (↓12 ★ ‖ -) }> Array (Byte))
    in %19 as ()
  } else {
    let
      0: %7: {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
       = unwrap custom Tree~0 %2 as {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
      1: %8: Bool
       = check variant 1 %7 as {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
      2: %9: Bool
       = if %8 as Bool {
        let
          0: %9: &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))
           = unwrap variant 1 %7 as {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))}
          1: %10: ({●<∅> Array (Byte), ●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●<∅> Array (Byte), ●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
           = unwrap boxed %9 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓2 ↓1 (↓1 ★ ‖ -)) }> Boxed (({●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {●@●<∅> Array (Byte), ●@●<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}))
          2: %11: {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
           = tuple field 0 %10 as ({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
          3: %12: Bool
           = True
          4: %13: {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}
           = tuple field 1 %10 as ({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
          5: %14: Bool
           = True
          6: %15: Bool
           = if %12 as Bool {
            if %14 as Bool {
              True
            } else {
              False
            }
          } else {
            False
          }
        in %15 as Bool
      } else {
        False
      }
      // guard_types: lowered from condition 'custom #0 (variant 1 (boxed ((_, _))))'
      3: %10: ()
       = if %9 as Bool {
        let
          0: %10: {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))}
           = unwrap custom Tree~0 %2 as {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}
          1: %11: &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))
           = unwrap variant 1 %10 as {&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))}
          2: %12: ({●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))})
           = unwrap boxed %11 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓2 ★ ‖ -)) }> Boxed (({●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}))
          3: %13: {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}
           = tuple field 0 %12 as ({&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, {&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))})
          4: %14: {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}
           = tuple field 1 %12 as ({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}, {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))})
          5...12: %15...%22: Byte = "Branch(\n"
          13: %23: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓14 ★ ‖ -)) }> Array (Byte)
           = [%15...%22]
          14: %24: ()
           = output(%23 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓14 ★ ‖ -)) }> Array (Byte))
          15: %25: Int
           = 1
          16: %26: (Int, Int)
           = (%3 as Int, %25 as Int)
          17: %27: Int
           = add_int %26 as (Int, Int)
          18: %28: ()
           = call print_indent#5 (%27 as Int)
          19: %29: Int
           = 1
          20: %30: (Int, Int)
           = (%3 as Int, %29 as Int)
          21: %31: Int
           = add_int %30 as (Int, Int)
          22: %32: (Closure~53<>, {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, Int)
           = (%1 as Closure~53<>, %13 as {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, %31 as Int)
          23: %33: ()
           = call print_tree_rec#1 (%32 as (Closure~53<>, {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓23 ★ ‖ -)) }>>))}, Int))
          24...25: %34...%35: Byte = ",\n"
          26: %36: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓27 ★ ‖ -)) }> Array (Byte)
           = [%34...%35]
          27: %37: ()
           = output(%36 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓27 ★ ‖ -)) }> Array (Byte))
          28: %38: Int
           = 1
          29: %39: (Int, Int)
           = (%3 as Int, %38 as Int)
          30: %40: Int
           = add_int %39 as (Int, Int)
          31: %41: ()
           = call print_indent#4 (%40 as Int)
          32: %42: Int
           = 1
          33: %43: (Int, Int)
           = (%3 as Int, %42 as Int)
          34: %44: Int
           = add_int %43 as (Int, Int)
          35: %45: (Closure~53<>, {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int)
           = (%1 as Closure~53<>, %14 as {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, %44 as Int)
          36: %46: ()
           = call print_tree_rec#1 (%45 as (Closure~53<>, {&<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }> Boxed ((Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>, Tree~0<●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>, ●@●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓36 ★ ‖ -)) }>>))}, Int))
          37: %47: Byte
           = '\n'
          38: %48: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓39 ★ ‖ -)) }> Array (Byte)
           = [%47]
          39: %49: ()
           = output(%48 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓39 ★ ‖ -)) }> Array (Byte))
          40: %50: ()
           = call print_indent#3 (%3 as Int)
          41: %51: Byte
           = ')'
          42: %52: ●<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓43 ★ ‖ -)) }> Array (Byte)
           = [%51]
          43: %53: ()
           = output(%52 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓3 ↓1 (↓43 ★ ‖ -)) }> Array (Byte))
        in %53 as ()
      } else {
        let
          0: %10: ()
           = unreachable
        in %10 as ()
      }
    in %10 as ()
  }
in %7 as ()

func print_indent#0 (%0: Int): () =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = lte_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ()
   = if %3 as Bool {
    let
      0: %4: ()
       = ()
    in %4 as ()
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ()
       = if %4 as Bool {
        let
          0...1: %5...%6: Byte = "  "
          2: %7: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte)
           = [%5...%6]
          3: %8: ()
           = output(%7 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte))
          4: %9: Int
           = 1
          5: %10: (Int, Int)
           = (%0 as Int, %9 as Int)
          6: %11: Int
           = sub_int %10 as (Int, Int)
          7: %12: ()
           = call print_indent#0 (%11 as Int)
        in %12 as ()
      } else {
        let
          0: %5: ()
           = unreachable
        in %5 as ()
      }
    in %5 as ()
  }
in %4 as ()

func print_indent#1 (%0: Int): () =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = lte_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ()
   = if %3 as Bool {
    let
      0: %4: ()
       = ()
    in %4 as ()
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ()
       = if %4 as Bool {
        let
          0...1: %5...%6: Byte = "  "
          2: %7: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte)
           = [%5...%6]
          3: %8: ()
           = output(%7 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte))
          4: %9: Int
           = 1
          5: %10: (Int, Int)
           = (%0 as Int, %9 as Int)
          6: %11: Int
           = sub_int %10 as (Int, Int)
          7: %12: ()
           = call print_indent#1 (%11 as Int)
        in %12 as ()
      } else {
        let
          0: %5: ()
           = unreachable
        in %5 as ()
      }
    in %5 as ()
  }
in %4 as ()

func print_indent#2 (%0: Int): () =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = lte_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ()
   = if %3 as Bool {
    let
      0: %4: ()
       = ()
    in %4 as ()
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ()
       = if %4 as Bool {
        let
          0...1: %5...%6: Byte = "  "
          2: %7: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte)
           = [%5...%6]
          3: %8: ()
           = output(%7 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte))
          4: %9: Int
           = 1
          5: %10: (Int, Int)
           = (%0 as Int, %9 as Int)
          6: %11: Int
           = sub_int %10 as (Int, Int)
          7: %12: ()
           = call print_indent#2 (%11 as Int)
        in %12 as ()
      } else {
        let
          0: %5: ()
           = unreachable
        in %5 as ()
      }
    in %5 as ()
  }
in %4 as ()

func test#1 (%0: (Int, &<{ ↓0 ↓8 ★ }> Array (Byte))): () =
let
  0: %1: Int
   = tuple field 0 %0 as (Int, &<∅> Array (Byte))
  1: %2: &<{ ↓0 ↓8 ★ }> Array (Byte)
   = tuple field 1 %0 as (Int, &<{ ↓0 ↓8 ★ }> Array (Byte))
  2: %3: ●<{ ↓0 ↓3 ★ }> Array (Byte)
   = call int_to_string#0 (%1 as Int)
  3: %4: ()
   = output(%3 as &<{ ↓0 ↓3 ★ }> Array (Byte))
  4...5: %5...%6: Byte = ", "
  6: %7: ●<{ ↓0 ↓7 ★ }> Array (Byte)
   = [%5...%6]
  7: %8: ()
   = output(%7 as &<{ ↓0 ↓7 ★ }> Array (Byte))
  8: %9: ()
   = output(%2 as &<{ ↓0 ↓8 ★ }> Array (Byte))
in %9 as ()

func bind#2 (%0: ((&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>), Int)): (Int, {(Int, ●<'12> Array (Byte)), ●<'13> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'16>, ●@●<'17>>))}) =
let
  0: %1: (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>)
   = tuple field 0 %0 as ((&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>), Int)
  1: %2: &<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>)
   = tuple field 0 %1 as (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~3<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>)
  2: %3: Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>
   = tuple field 1 %1 as (&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>)
  3: %4: Int
   = tuple field 1 %0 as ((&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~3<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Int)
  4: %5: (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), Int)
   = (%2 as &<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), %4 as Int)
  5: %6: (Int, {(Int, ●<'14> Array (Byte)), ●<'15> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'14>, ●@●<'15>>))})
   = call run#0 (%5 as (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'14>, ●@●<{ ↓0 ↓5 ★ }>>), Int))
  6: %7: Int
   = tuple field 0 %6 as (Int, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  7: %8: {(Int, ●<'14> Array (Byte)), ●<'15> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'14>, ●@●<'15>>))}
   = tuple field 1 %6 as (Int, {(Int, ●<'14> Array (Byte)), ●<'15> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  8: %9: (Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>, {(Int, ●<'14> Array (Byte)), ●<'15> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'14>, ●@●<'15>>))})
   = (%3 as Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>, %8 as {(Int, ●<'14> Array (Byte)), ●<'15> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  9: %10: State~7<●<{ ↓0 ↓11 ★ }>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●<'14>, ●<'15>, ●@●<'14>, ●@●<'15>, ●@●<'14>, ●@●<'15>>
   = call dispatch#4 (%9 as (Closure~3<●<'16>, &<{ ↓0 ↓9 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>>, {(Int, ●<'14> Array (Byte)), ●<'15> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'14>, ●@●<'15>>))}))
  10: %11: (State~7<&<{ ↓0 ↓11 ★ }>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●<'14>, ●<'15>, ●@●<'14>, ●@●<'15>, ●@●<'14>, ●@●<'15>>, Int)
   = (%10 as State~7<&<{ ↓0 ↓11 ★ }>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●<'14>, ●<'15>, ●@●<'14>, ●@●<'15>, ●@●<'14>, ●@●<'15>>, %7 as Int)
  11: %12: (Int, {(Int, ●<'12> Array (Byte)), ●<'13> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'16>, ●@●<'17>>))})
   = call run#1 (%11 as (State~7<&<{ ↓0 ↓11 ★ }>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●@●<'16>, ●@●<{ ↓0 ↓11 ★ }>, ●<'14>, ●<'15>, ●@●<'14>, ●@●<'15>, ●@●<'14>, ●@●<'15>>, Int))
in %12 as (Int, {(Int, ●<'12> Array (Byte)), ●<'13> Boxed ((Tree~1<●@●<'14>, ●@●<'15>>, Tree~1<●@●<'16>, ●@●<'17>>))})

func bind#3 (%0: ((State~6<>, Closure~2<●<'0>>), Int)): (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}) =
let
  0: %1: (State~6<>, Closure~2<●<'0>>)
   = tuple field 0 %0 as ((State~6<>, Closure~2<●<'0>>), Int)
  1: %2: State~6<>
   = tuple field 0 %1 as (State~6<>, Closure~2<&<∅>>)
  2: %3: Closure~2<●<'0>>
   = tuple field 1 %1 as (State~6<>, Closure~2<●<'0>>)
  3: %4: Int
   = tuple field 1 %0 as ((State~6<>, Closure~2<&<∅>>), Int)
  4: %5: (State~6<>, Int)
   = (%2 as State~6<>, %4 as Int)
  5: %6: (Int, Int)
   = call run#3 (%5 as (State~6<>, Int))
  6: %7: Int
   = tuple field 0 %6 as (Int, Int)
  7: %8: Int
   = tuple field 1 %6 as (Int, Int)
  8: %9: (Closure~2<●<'0>>, Int)
   = (%3 as Closure~2<●<'0>>, %8 as Int)
  9: %10: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = call dispatch#5 (%9 as (Closure~2<●<'0>>, Int))
  10: %11: (State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int)
   = (%10 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, %7 as Int)
  11: %12: (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = call run#2 (%11 as (State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int))
in %12 as (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})

func bind#4 (%0: (State~5<>, Closure~10<>)): State~6<> =
let
  0: %1: State~5<>
   = tuple field 0 %0 as (State~5<>, Closure~10<>)
  1: %2: Closure~10<>
   = tuple field 1 %0 as (State~5<>, Closure~10<>)
  2: %3: (State~5<>, Closure~10<>)
   = (%1 as State~5<>, %2 as Closure~10<>)
  3: %4: Closure~9<>
   = wrap custom Closure~9 %3 as (State~5<>, Closure~10<>)
  4: %5: State~6<>
   = wrap custom State~6 %4 as Closure~9<>
in %5 as State~6<>

func get.const#0 (%0: ()): State~5<> =
let
  0: %1: ()
   = ()
  1: %2: Closure~8<>
   = wrap custom Closure~8 %1 as ()
  2: %3: State~5<>
   = wrap custom State~5 %2 as Closure~8<>
in %3 as State~5<>

func print_indent#3 (%0: Int): () =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = lte_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ()
   = if %3 as Bool {
    let
      0: %4: ()
       = ()
    in %4 as ()
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ()
       = if %4 as Bool {
        let
          0...1: %5...%6: Byte = "  "
          2: %7: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte)
           = [%5...%6]
          3: %8: ()
           = output(%7 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte))
          4: %9: Int
           = 1
          5: %10: (Int, Int)
           = (%0 as Int, %9 as Int)
          6: %11: Int
           = sub_int %10 as (Int, Int)
          7: %12: ()
           = call print_indent#3 (%11 as Int)
        in %12 as ()
      } else {
        let
          0: %5: ()
           = unreachable
        in %5 as ()
      }
    in %5 as ()
  }
in %4 as ()

func print_indent#4 (%0: Int): () =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = lte_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ()
   = if %3 as Bool {
    let
      0: %4: ()
       = ()
    in %4 as ()
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ()
       = if %4 as Bool {
        let
          0...1: %5...%6: Byte = "  "
          2: %7: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte)
           = [%5...%6]
          3: %8: ()
           = output(%7 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte))
          4: %9: Int
           = 1
          5: %10: (Int, Int)
           = (%0 as Int, %9 as Int)
          6: %11: Int
           = sub_int %10 as (Int, Int)
          7: %12: ()
           = call print_indent#4 (%11 as Int)
        in %12 as ()
      } else {
        let
          0: %5: ()
           = unreachable
        in %5 as ()
      }
    in %5 as ()
  }
in %4 as ()

func print_indent#5 (%0: Int): () =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = lte_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ()
   = if %3 as Bool {
    let
      0: %4: ()
       = ()
    in %4 as ()
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ()
       = if %4 as Bool {
        let
          0...1: %5...%6: Byte = "  "
          2: %7: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte)
           = [%5...%6]
          3: %8: ()
           = output(%7 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ★ ‖ -)) }> Array (Byte))
          4: %9: Int
           = 1
          5: %10: (Int, Int)
           = (%0 as Int, %9 as Int)
          6: %11: Int
           = sub_int %10 as (Int, Int)
          7: %12: ()
           = call print_indent#5 (%11 as Int)
        in %12 as ()
      } else {
        let
          0: %5: ()
           = unreachable
        in %5 as ()
      }
    in %5 as ()
  }
in %4 as ()

func int_to_string#0 (%0: Int): ●<'0> Array (Byte) =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Bool
   = eq_int %2 as (Int, Int)
  // guard_types: lowered from condition 'True'
  3: %4: ●<'0> Array (Byte)
   = if %3 as Bool {
    let
      0: %4: Byte
       = '0'
      1: %5: ●<'0> Array (Byte)
       = [%4]
    in %5 as ●<'0> Array (Byte)
  } else {
    let
      0: %4: Bool
       = if %3 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %5: ●<'0> Array (Byte)
       = if %4 as Bool {
        let
          0: %5: Int
           = 0
          1: %6: (Int, Int)
           = (%0 as Int, %5 as Int)
          2: %7: Bool
           = lt_int %6 as (Int, Int)
          // guard_types: lowered from condition 'True'
          3: %8: ●<'0> Array (Byte)
           = if %7 as Bool {
            let
              0: %8: Byte
               = '-'
              1: %9: ●<'0> Array (Byte)
               = [%8]
              2: %10: Int
               = 0
              3: %11: (Int, Int)
               = (%10 as Int, %0 as Int)
              4: %12: Int
               = sub_int %11 as (Int, Int)
              5: %13: ●<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ↓1 (↓7 ★ ‖ -) ‖ -)) }> Array (Byte)
               = call nat_to_string#1 (%12 as Int)
              6: %14: (●<'0> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ↓1 (↓7 ★ ‖ -) ‖ -)) }> Array (Byte))
               = (%9 as ●<'0> Array (Byte), %13 as &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ↓1 (↓7 ★ ‖ -) ‖ -)) }> Array (Byte))
              7: %15: ●<'0> Array (Byte)
               = call concat#0 (%14 as (●<'0> Array (Byte), &<{ ↓0 ↓3 ↓1 (- ‖ ↓1 ↓1 (↓3 ↓1 (↓7 ★ ‖ -) ‖ -)) }> Array (Byte)))
            in %15 as ●<'0> Array (Byte)
          } else {
            let
              0: %8: Bool
               = if %7 as Bool {
                False
              } else {
                True
              }
              // guard_types: lowered from condition 'False'
              1: %9: ●<'0> Array (Byte)
               = if %8 as Bool {
                let
                  0: %9: ●<'0> Array (Byte)
                   = call nat_to_string#0 (%0 as Int)
                in %9 as ●<'0> Array (Byte)
              } else {
                let
                  0: %9: ●<'0> Array (Byte)
                   = unreachable
                in %9 as ●<'0> Array (Byte)
              }
            in %9 as ●<'0> Array (Byte)
          }
        in %8 as ●<'0> Array (Byte)
      } else {
        let
          0: %5: ●<'0> Array (Byte)
           = unreachable
        in %5 as ●<'0> Array (Byte)
      }
    in %5 as ●<'0> Array (Byte)
  }
in %4 as ●<'0> Array (Byte)

func run#1 (%0: (State~7<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>, Int)): (Int, {(Int, ●<'18> Array (Byte)), ●<'19> Boxed ((Tree~1<●@●<'20>, ●@●<'21>>, Tree~1<●@●<'22>, ●@●<'23>>))}) =
let
  0: %1: State~7<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>
   = tuple field 0 %0 as (State~7<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~7<&<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, &<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Int)
  2: %3: Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>
   = unwrap custom State~7 %1 as State~7<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>
  3: %4: (Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>, Int)
   = (%3 as Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>, %2 as Int)
  4: %5: (Int, {(Int, ●<'18> Array (Byte)), ●<'19> Boxed ((Tree~1<●@●<'20>, ●@●<'21>>, Tree~1<●@●<'22>, ●@●<'23>>))})
   = call dispatch#6 (%4 as (Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'22>, ●@●<{ ↓0 ↓4 ★ }>, ●<'20>, ●<'21>, ●@●<'20>, ●@●<'21>, ●@●<'20>, ●@●<'21>>, Int))
in %5 as (Int, {(Int, ●<'18> Array (Byte)), ●<'19> Boxed ((Tree~1<●@●<'20>, ●@●<'21>>, Tree~1<●@●<'22>, ●@●<'23>>))})

func dispatch#4 (%0: (Closure~3<●<'2>, &<{ ↓0 ↓4 ★ }>, ●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>, ●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})): State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>> =
let
  0: %1: Closure~3<●<'2>, &<{ ↓0 ↓4 ★ }>, ●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>, ●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>
   = tuple field 0 %0 as (Closure~3<●<'2>, &<{ ↓0 ↓4 ★ }>, ●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>, ●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  1: %2: {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))}
   = tuple field 1 %0 as (Closure~3<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  2: %3: ({●<'2> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))})
   = unwrap custom Closure~3 %1 as Closure~3<●<'2>, &<{ ↓0 ↓4 ★ }>, ●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>, ●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>
  3: %4: (({●<'2> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}), {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
   = (%3 as ({●<'2> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}), %2 as {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  4: %5: State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
   = call index_leaves#1 (%4 as (({●<'2> Array (Byte), &<{ ↓0 ↓4 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}), {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))}))
in %5 as State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>

func run#2 (%0: (State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int)): (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}) =
let
  0: %1: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = tuple field 0 %0 as (State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~0<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Int)
  2: %3: Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = unwrap custom State~0 %1 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
  3: %4: (Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int)
   = (%3 as Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, %2 as Int)
  4: %5: (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = call dispatch#7 (%4 as (Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int))
in %5 as (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})

func dispatch#5 (%0: (Closure~2<●<'0>>, Int)): State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>> =
let
  0: %1: Closure~2<●<'0>>
   = tuple field 0 %0 as (Closure~2<●<'0>>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~2<&<∅>>, Int)
  2: %3: (●<'0> Array (Byte))
   = unwrap custom Closure~2 %1 as Closure~2<●<'0>>
  3: %4: ((●<'0> Array (Byte)), Int)
   = (%3 as (●<'0> Array (Byte)), %2 as Int)
  4: %5: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = call index_leaves#2 (%4 as ((●<'0> Array (Byte)), Int))
in %5 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>

func run#3 (%0: (State~6<>, Int)): (Int, Int) =
let
  0: %1: State~6<>
   = tuple field 0 %0 as (State~6<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~6<>, Int)
  2: %3: Closure~9<>
   = unwrap custom State~6 %1 as State~6<>
  3: %4: (Closure~9<>, Int)
   = (%3 as Closure~9<>, %2 as Int)
  4: %5: (Int, Int)
   = call dispatch#8 (%4 as (Closure~9<>, Int))
in %5 as (Int, Int)

func nat_to_string#0 (%0: Int): ●<'0> Array (Byte) =
let
  0: %1: ()
   = ()
  1: %2: Closure~55<>
   = wrap custom Closure~55 %1 as ()
  2: %3: Int
   = 0
  3: %4: (Int, Int)
   = (%0 as Int, %3 as Int)
  4: %5: Bool
   = eq_int %4 as (Int, Int)
  // guard_types: lowered from condition 'True'
  5: %6: ●<'0> Array (Byte)
   = if %5 as Bool {
    let
      0: %6: ●<'0> Array (Byte)
       = []
    in %6 as ●<'0> Array (Byte)
  } else {
    let
      0: %6: Bool
       = if %5 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %7: ●<'0> Array (Byte)
       = if %6 as Bool {
        let
          0: %7: Int
           = 10
          1: %8: (Int, Int)
           = (%0 as Int, %7 as Int)
          2: %9: Int
           = div_int %8 as (Int, Int)
          3: %10: ●<'0> Array (Byte)
           = call nat_to_string#0 (%9 as Int)
          4: %11: Int
           = 10
          5: %12: (Int, Int)
           = (%0 as Int, %11 as Int)
          6: %13: Int
           = div_int %12 as (Int, Int)
          7: %14: Int
           = 10
          8: %15: (Int, Int)
           = (%13 as Int, %14 as Int)
          9: %16: Int
           = mul_int %15 as (Int, Int)
          10: %17: (Int, Int)
           = (%0 as Int, %16 as Int)
          11: %18: Int
           = sub_int %17 as (Int, Int)
          12: %19: ●<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte)
           = call nat_to_string#2 (%18 as Int)
          13: %20: (●<'0> Array (Byte), &<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte))
           = (%10 as ●<'0> Array (Byte), %19 as &<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte))
          14: %21: ●<'0> Array (Byte)
           = call concat#0 (%20 as (●<'0> Array (Byte), &<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte)))
        in %21 as ●<'0> Array (Byte)
      } else {
        let
          0: %7: ●<'0> Array (Byte)
           = unreachable
        in %7 as ●<'0> Array (Byte)
      }
    in %7 as ●<'0> Array (Byte)
  }
in %6 as ●<'0> Array (Byte)

func concat#0 (%0: (●<'0> Array (Byte), &<{ ↓0 ↓4 ★ }> Array (Byte))): ●<'0> Array (Byte) =
let
  0: %1: ●<'0> Array (Byte)
   = tuple field 0 %0 as (●<'0> Array (Byte), &<∅> Array (Byte))
  1: %2: &<{ ↓0 ↓4 ★ }> Array (Byte)
   = tuple field 1 %0 as (&<∅> Array (Byte), &<{ ↓0 ↓4 ★ }> Array (Byte))
  2: %3: Int
   = 0
  3: %4: (●<'0> Array (Byte), &<{ ↓0 ↓4 ★ }> Array (Byte), Int)
   = (%1 as ●<'0> Array (Byte), %2 as &<{ ↓0 ↓4 ★ }> Array (Byte), %3 as Int)
  4: %5: ●<'0> Array (Byte)
   = call concat_from#0 (%4 as (●<'0> Array (Byte), &<{ ↓0 ↓4 ★ }> Array (Byte), Int))
in %5 as ●<'0> Array (Byte)

func nat_to_string#1 (%0: Int): ●<'0> Array (Byte) =
let
  0: %1: ()
   = ()
  1: %2: Closure~55<>
   = wrap custom Closure~55 %1 as ()
  2: %3: Int
   = 0
  3: %4: (Int, Int)
   = (%0 as Int, %3 as Int)
  4: %5: Bool
   = eq_int %4 as (Int, Int)
  // guard_types: lowered from condition 'True'
  5: %6: ●<'0> Array (Byte)
   = if %5 as Bool {
    let
      0: %6: ●<'0> Array (Byte)
       = []
    in %6 as ●<'0> Array (Byte)
  } else {
    let
      0: %6: Bool
       = if %5 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %7: ●<'0> Array (Byte)
       = if %6 as Bool {
        let
          0: %7: Int
           = 10
          1: %8: (Int, Int)
           = (%0 as Int, %7 as Int)
          2: %9: Int
           = div_int %8 as (Int, Int)
          3: %10: ●<'0> Array (Byte)
           = call nat_to_string#1 (%9 as Int)
          4: %11: Int
           = 10
          5: %12: (Int, Int)
           = (%0 as Int, %11 as Int)
          6: %13: Int
           = div_int %12 as (Int, Int)
          7: %14: Int
           = 10
          8: %15: (Int, Int)
           = (%13 as Int, %14 as Int)
          9: %16: Int
           = mul_int %15 as (Int, Int)
          10: %17: (Int, Int)
           = (%0 as Int, %16 as Int)
          11: %18: Int
           = sub_int %17 as (Int, Int)
          12: %19: ●<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte)
           = call nat_to_string#2 (%18 as Int)
          13: %20: (●<'0> Array (Byte), &<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte))
           = (%10 as ●<'0> Array (Byte), %19 as &<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte))
          14: %21: ●<'0> Array (Byte)
           = call concat#0 (%20 as (●<'0> Array (Byte), &<{ ↓0 ↓5 ↓1 (- ‖ ↓1 ↓1 (↓14 ★ ‖ -)) }> Array (Byte)))
        in %21 as ●<'0> Array (Byte)
      } else {
        let
          0: %7: ●<'0> Array (Byte)
           = unreachable
        in %7 as ●<'0> Array (Byte)
      }
    in %7 as ●<'0> Array (Byte)
  }
in %6 as ●<'0> Array (Byte)

func dispatch#6 (%0: (Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>, Int)): (Int, {(Int, ●<'24> Array (Byte)), ●<'25> Boxed ((Tree~1<●@●<'26>, ●@●<'27>>, Tree~1<●@●<'28>, ●@●<'29>>))}) =
let
  0: %1: Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>
   = tuple field 0 %0 as (Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~11<&<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, &<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Int)
  2: %3: (&<{ ↓0 ↓4 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>>), Closure~12<●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>)
   = unwrap custom Closure~11 %1 as Closure~11<&<{ ↓0 ↓4 ★ }>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>
  3: %4: ((&<{ ↓0 ↓4 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>>), Closure~12<●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>), Int)
   = (%3 as (&<{ ↓0 ↓4 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>>), Closure~12<●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>), %2 as Int)
  4: %5: (Int, {(Int, ●<'24> Array (Byte)), ●<'25> Boxed ((Tree~1<●@●<'26>, ●@●<'27>>, Tree~1<●@●<'28>, ●@●<'29>>))})
   = call bind#5 (%4 as ((&<{ ↓0 ↓4 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>, ●@●<'28>, ●@●<{ ↓0 ↓4 ★ }>>), Closure~12<●<'26>, ●<'27>, ●@●<'26>, ●@●<'27>, ●@●<'26>, ●@●<'27>>), Int))
in %5 as (Int, {(Int, ●<'24> Array (Byte)), ●<'25> Boxed ((Tree~1<●@●<'26>, ●@●<'27>>, Tree~1<●@●<'28>, ●@●<'29>>))})

func index_leaves#1 (%0: (({●<'2> Array (Byte), &<{ ↓0 ↓3 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}), {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})): State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>> =
let
  0: %1: ({●<'2> Array (Byte), &<{ ↓0 ↓3 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))})
   = tuple field 0 %0 as (({●<'2> Array (Byte), &<{ ↓0 ↓3 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}), {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  1: %2: {●<'2> Array (Byte), &<{ ↓0 ↓3 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))}
   = tuple field 0 %1 as ({●<'2> Array (Byte), &<{ ↓0 ↓3 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))})
  2: %3: {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))}
   = tuple field 1 %0 as (({&<∅> Array (Byte), &<∅> Boxed ((Tree~0<●@●<∅>, ●@●<∅>>, Tree~0<●@●<∅>, ●@●<∅>>))}), {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  3: %4: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = call index_leaves#0 (%2 as {●<'2> Array (Byte), &<{ ↓0 ↓3 ★ }> Boxed ((Tree~0<●@●<'2 ⨆ '4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>, Tree~0<●@●<'4 ⨆ '6 ⨆ '8>, ●@●<'5 ⨆ '7 ⨆ '9>>))})
  4: %5: ({(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
   = (%3 as {(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  5: %6: Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
   = wrap custom Closure~12 %5 as ({(Int, ●<'10> Array (Byte)), ●<'11> Boxed ((Tree~1<●@●<'12>, ●@●<'13>>, Tree~1<●@●<'14>, ●@●<'15>>))})
  6: %7: (●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)
   = (%4 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), %6 as Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)
  7: %8: State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
   = call bind#6 (%7 as (●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>))
in %8 as State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>

func dispatch#7 (%0: (Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int)): (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}) =
let
  0: %1: Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = tuple field 0 %0 as (Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~0<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, Int)
  2: %3: ({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = unwrap custom Closure~0 %1 as Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
  3: %4: (({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}), Int)
   = (%3 as ({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}), %2 as Int)
  4: %5: (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = call pure#0 (%4 as (({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}), Int))
in %5 as (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})

func index_leaves#2 (%0: ((●<'0> Array (Byte)), Int)): State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>> =
let
  0: %1: (●<'0> Array (Byte))
   = tuple field 0 %0 as ((●<'0> Array (Byte)), Int)
  1: %2: ●<'0> Array (Byte)
   = tuple field 0 %1 as (●<'0> Array (Byte))
  2: %3: Int
   = tuple field 1 %0 as ((&<∅> Array (Byte)), Int)
  3: %4: (Int, ●<'0> Array (Byte))
   = (%3 as Int, %2 as ●<'0> Array (Byte))
  4: %5: {(Int, ●<'0> Array (Byte)), ●<'1> Boxed (({(Int, ●@●<'2> Array (Byte)), ●@●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●@●<'4> Array (Byte)), ●@●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))}
   = wrap variant 0 %4 as (Int, ●<'0> Array (Byte))
  5: %6: {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}
   = wrap custom Tree~1 %5 as {(Int, ●<'0> Array (Byte)), ●<'1> Boxed (({(Int, ●@●<'2> Array (Byte)), ●@●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●@●<'4> Array (Byte)), ●@●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))}
  6: %7: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = call pure#1 (%6 as {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
in %7 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>

func dispatch#8 (%0: (Closure~9<>, Int)): (Int, Int) =
let
  0: %1: Closure~9<>
   = tuple field 0 %0 as (Closure~9<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~9<>, Int)
  2: %3: (State~5<>, Closure~10<>)
   = unwrap custom Closure~9 %1 as Closure~9<>
  3: %4: ((State~5<>, Closure~10<>), Int)
   = (%3 as (State~5<>, Closure~10<>), %2 as Int)
  4: %5: (Int, Int)
   = call bind#7 (%4 as ((State~5<>, Closure~10<>), Int))
in %5 as (Int, Int)

func nat_to_string#2 (%0: Int): ●<'0> Array (Byte) =
let
  0: %1: Int
   = 0
  1: %2: (Int, Int)
   = (%1 as Int, %0 as Int)
  2: %3: Bool
   = eq_int %2 as (Int, Int)
  // guard_types: lowered from condition '0'
  3: %4: ●<'0> Array (Byte)
   = if %3 as Bool {
    let
      0: %4: Byte
       = '0'
      1: %5: ●<'0> Array (Byte)
       = [%4]
    in %5 as ●<'0> Array (Byte)
  } else {
    let
      0: %4: Int
       = 1
      1: %5: (Int, Int)
       = (%4 as Int, %0 as Int)
      2: %6: Bool
       = eq_int %5 as (Int, Int)
      // guard_types: lowered from condition '1'
      3: %7: ●<'0> Array (Byte)
       = if %6 as Bool {
        let
          0: %7: Byte
           = '1'
          1: %8: ●<'0> Array (Byte)
           = [%7]
        in %8 as ●<'0> Array (Byte)
      } else {
        let
          0: %7: Int
           = 2
          1: %8: (Int, Int)
           = (%7 as Int, %0 as Int)
          2: %9: Bool
           = eq_int %8 as (Int, Int)
          // guard_types: lowered from condition '2'
          3: %10: ●<'0> Array (Byte)
           = if %9 as Bool {
            let
              0: %10: Byte
               = '2'
              1: %11: ●<'0> Array (Byte)
               = [%10]
            in %11 as ●<'0> Array (Byte)
          } else {
            let
              0: %10: Int
               = 3
              1: %11: (Int, Int)
               = (%10 as Int, %0 as Int)
              2: %12: Bool
               = eq_int %11 as (Int, Int)
              // guard_types: lowered from condition '3'
              3: %13: ●<'0> Array (Byte)
               = if %12 as Bool {
                let
                  0: %13: Byte
                   = '3'
                  1: %14: ●<'0> Array (Byte)
                   = [%13]
                in %14 as ●<'0> Array (Byte)
              } else {
                let
                  0: %13: Int
                   = 4
                  1: %14: (Int, Int)
                   = (%13 as Int, %0 as Int)
                  2: %15: Bool
                   = eq_int %14 as (Int, Int)
                  // guard_types: lowered from condition '4'
                  3: %16: ●<'0> Array (Byte)
                   = if %15 as Bool {
                    let
                      0: %16: Byte
                       = '4'
                      1: %17: ●<'0> Array (Byte)
                       = [%16]
                    in %17 as ●<'0> Array (Byte)
                  } else {
                    let
                      0: %16: Int
                       = 5
                      1: %17: (Int, Int)
                       = (%16 as Int, %0 as Int)
                      2: %18: Bool
                       = eq_int %17 as (Int, Int)
                      // guard_types: lowered from condition '5'
                      3: %19: ●<'0> Array (Byte)
                       = if %18 as Bool {
                        let
                          0: %19: Byte
                           = '5'
                          1: %20: ●<'0> Array (Byte)
                           = [%19]
                        in %20 as ●<'0> Array (Byte)
                      } else {
                        let
                          0: %19: Int
                           = 6
                          1: %20: (Int, Int)
                           = (%19 as Int, %0 as Int)
                          2: %21: Bool
                           = eq_int %20 as (Int, Int)
                          // guard_types: lowered from condition '6'
                          3: %22: ●<'0> Array (Byte)
                           = if %21 as Bool {
                            let
                              0: %22: Byte
                               = '6'
                              1: %23: ●<'0> Array (Byte)
                               = [%22]
                            in %23 as ●<'0> Array (Byte)
                          } else {
                            let
                              0: %22: Int
                               = 7
                              1: %23: (Int, Int)
                               = (%22 as Int, %0 as Int)
                              2: %24: Bool
                               = eq_int %23 as (Int, Int)
                              // guard_types: lowered from condition '7'
                              3: %25: ●<'0> Array (Byte)
                               = if %24 as Bool {
                                let
                                  0: %25: Byte
                                   = '7'
                                  1: %26: ●<'0> Array (Byte)
                                   = [%25]
                                in %26 as ●<'0> Array (Byte)
                              } else {
                                let
                                  0: %25: Int
                                   = 8
                                  1: %26: (Int, Int)
                                   = (%25 as Int, %0 as Int)
                                  2: %27: Bool
                                   = eq_int %26 as (Int, Int)
                                  // guard_types: lowered from condition '8'
                                  3: %28: ●<'0> Array (Byte)
                                   = if %27 as Bool {
                                    let
                                      0: %28: Byte
                                       = '8'
                                      1: %29: ●<'0> Array (Byte)
                                       = [%28]
                                    in %29 as ●<'0> Array (Byte)
                                  } else {
                                    let
                                      0: %28: Int
                                       = 9
                                      1: %29: (Int, Int)
                                       = (%28 as Int, %0 as Int)
                                      2: %30: Bool
                                       = eq_int %29 as (Int, Int)
                                      // guard_types: lowered from condition '9'
                                      3: %31: ●<'0> Array (Byte)
                                       = if %30 as Bool {
                                        let
                                          0: %31: Byte
                                           = '9'
                                          1: %32: ●<'0> Array (Byte)
                                           = [%31]
                                        in %32 as ●<'0> Array (Byte)
                                      } else {
                                        let
                                          0: %31: Bool
                                           = True
                                          // guard_types: lowered from condition '_'
                                          1: %32: ●<'0> Array (Byte)
                                           = if %31 as Bool {
                                            let
                                              0: %32: ●<'0> Array (Byte)
                                               = []
                                            in %32 as ●<'0> Array (Byte)
                                          } else {
                                            let
                                              0: %32: ●<'0> Array (Byte)
                                               = unreachable
                                            in %32 as ●<'0> Array (Byte)
                                          }
                                        in %32 as ●<'0> Array (Byte)
                                      }
                                    in %31 as ●<'0> Array (Byte)
                                  }
                                in %28 as ●<'0> Array (Byte)
                              }
                            in %25 as ●<'0> Array (Byte)
                          }
                        in %22 as ●<'0> Array (Byte)
                      }
                    in %19 as ●<'0> Array (Byte)
                  }
                in %16 as ●<'0> Array (Byte)
              }
            in %13 as ●<'0> Array (Byte)
          }
        in %10 as ●<'0> Array (Byte)
      }
    in %7 as ●<'0> Array (Byte)
  }
in %4 as ●<'0> Array (Byte)

func concat_from#0 (%0: (●<'0> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓6 ★ ‖ -)) }> Array (Byte), Int)): ●<'0> Array (Byte) =
let
  0: %1: ●<'0> Array (Byte)
   = tuple field 0 %0 as (●<'0> Array (Byte), &<∅> Array (Byte), Int)
  1: %2: &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓6 ★ ‖ -)) }> Array (Byte)
   = tuple field 1 %0 as (&<∅> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓6 ★ ‖ -)) }> Array (Byte), Int)
  2: %3: Int
   = tuple field 2 %0 as (&<∅> Array (Byte), &<∅> Array (Byte), Int)
  3: %4: Int
   = len(%2 as &<∅> Array (Byte))
  4: %5: (Int, Int)
   = (%3 as Int, %4 as Int)
  5: %6: Bool
   = eq_int %5 as (Int, Int)
  // guard_types: lowered from condition 'True'
  6: %7: ●<'0> Array (Byte)
   = if %6 as Bool {
    let
    in %1 as ●<'0> Array (Byte)
  } else {
    let
      0: %7: Bool
       = if %6 as Bool {
        False
      } else {
        True
      }
      // guard_types: lowered from condition 'False'
      1: %8: ●<'0> Array (Byte)
       = if %7 as Bool {
        let
          0: %8: Byte
           = get(%2 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓0 ↓0 ★ ‖ -)) }> Array (Byte), %3 as Int) as Byte
          1: %9: ●<'0> Array (Byte)
           = push(%1 as ●<'0> Array (Byte), %8 as Byte)
          2: %10: Int
           = 1
          3: %11: (Int, Int)
           = (%3 as Int, %10 as Int)
          4: %12: Int
           = add_int %11 as (Int, Int)
          5: %13: (●<'0> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓6 ★ ‖ -)) }> Array (Byte), Int)
           = (%9 as ●<'0> Array (Byte), %2 as &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓6 ★ ‖ -)) }> Array (Byte), %12 as Int)
          6: %14: ●<'0> Array (Byte)
           = call concat_from#0 (%13 as (●<'0> Array (Byte), &<{ ↓0 ↓6 ↓1 (- ‖ ↓1 ↓1 (↓6 ★ ‖ -)) }> Array (Byte), Int))
        in %14 as ●<'0> Array (Byte)
      } else {
        let
          0: %8: ●<'0> Array (Byte)
           = unreachable
        in %8 as ●<'0> Array (Byte)
      }
    in %8 as ●<'0> Array (Byte)
  }
in %7 as ●<'0> Array (Byte)

func bind#5 (%0: ((&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>), Int)): (Int, {(Int, ●<'30> Array (Byte)), ●<'31> Boxed ((Tree~1<●@●<'32>, ●@●<'33>>, Tree~1<●@●<'34>, ●@●<'35>>))}) =
let
  0: %1: (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>)
   = tuple field 0 %0 as ((&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>), Int)
  1: %2: &<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>)
   = tuple field 0 %1 as (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), Closure~12<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>)
  2: %3: Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>
   = tuple field 1 %1 as (&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>)
  3: %4: Int
   = tuple field 1 %0 as ((&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~12<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Int)
  4: %5: (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), Int)
   = (%2 as &<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), %4 as Int)
  5: %6: (Int, {(Int, ●<'34> Array (Byte)), ●<'35> Boxed ((Tree~1<●@●<'34>, ●@●<'35>>, Tree~1<●@●<'34>, ●@●<'35>>))})
   = call run#0 (%5 as (&<{ ↓0 ↓5 ★ }> Boxed (Closure~1<●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>, ●@●<'34>, ●@●<{ ↓0 ↓5 ★ }>>), Int))
  6: %7: Int
   = tuple field 0 %6 as (Int, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  7: %8: {(Int, ●<'34> Array (Byte)), ●<'35> Boxed ((Tree~1<●@●<'34>, ●@●<'35>>, Tree~1<●@●<'34>, ●@●<'35>>))}
   = tuple field 1 %6 as (Int, {(Int, ●<'34> Array (Byte)), ●<'35> Boxed ((Tree~1<●@●<'34>, ●@●<'35>>, Tree~1<●@●<'34>, ●@●<'35>>))})
  8: %9: (Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>, {(Int, ●<'34> Array (Byte)), ●<'35> Boxed ((Tree~1<●@●<'34>, ●@●<'35>>, Tree~1<●@●<'34>, ●@●<'35>>))})
   = (%3 as Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>, %8 as {(Int, ●<'34> Array (Byte)), ●<'35> Boxed ((Tree~1<●@●<'34>, ●@●<'35>>, Tree~1<●@●<'34>, ●@●<'35>>))})
  9: %10: State~0<●<'30>, ●<'31>, ●@●<'32>, ●@●<'33>, ●@●<'34>, ●@●<'35>>
   = call dispatch#9 (%9 as (Closure~12<●<'32>, ●<'33>, ●@●<'32>, ●@●<'33>, ●@●<'32>, ●@●<'33>>, {(Int, ●<'34> Array (Byte)), ●<'35> Boxed ((Tree~1<●@●<'34>, ●@●<'35>>, Tree~1<●@●<'34>, ●@●<'35>>))}))
  10: %11: (State~0<●<'30>, ●<'31>, ●@●<'32>, ●@●<'33>, ●@●<'34>, ●@●<'35>>, Int)
   = (%10 as State~0<●<'30>, ●<'31>, ●@●<'32>, ●@●<'33>, ●@●<'34>, ●@●<'35>>, %7 as Int)
  11: %12: (Int, {(Int, ●<'30> Array (Byte)), ●<'31> Boxed ((Tree~1<●@●<'32>, ●@●<'33>>, Tree~1<●@●<'34>, ●@●<'35>>))})
   = call run#2 (%11 as (State~0<●<'30>, ●<'31>, ●@●<'32>, ●@●<'33>, ●@●<'34>, ●@●<'35>>, Int))
in %12 as (Int, {(Int, ●<'30> Array (Byte)), ●<'31> Boxed ((Tree~1<●@●<'32>, ●@●<'33>>, Tree~1<●@●<'34>, ●@●<'35>>))})

func bind#6 (%0: (●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)): State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>> =
let
  0: %1: ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>)
   = tuple field 0 %0 as (●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~12<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>)
  1: %2: Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
   = tuple field 1 %0 as (&<∅> Boxed (Closure~1<●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>), Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)
  2: %3: (●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)
   = (%1 as ●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), %2 as Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)
  3: %4: Closure~11<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
   = wrap custom Closure~11 %3 as (●<'0> Boxed (Closure~1<●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>>), Closure~12<●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>)
  4: %5: State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
   = wrap custom State~7 %4 as Closure~11<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>
in %5 as State~7<●<'0>, ●@●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>, ●@●<'6>, ●@●<'7>, ●@●<'8>, ●@●<'9>, ●<'10>, ●<'11>, ●@●<'12>, ●@●<'13>, ●@●<'14>, ●@●<'15>>

func pure#0 (%0: (({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}), Int)): (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}) =
let
  0: %1: ({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = tuple field 0 %0 as (({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}), Int)
  1: %2: {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}
   = tuple field 0 %1 as ({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  2: %3: Int
   = tuple field 1 %0 as (({(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}), Int)
  3: %4: (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = (%3 as Int, %2 as {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
in %4 as (Int, {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})

func pure#1 (%0: {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}): State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>> =
let
  0: %1: ({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = (%0 as {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  1: %2: Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = wrap custom Closure~0 %1 as ({(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  2: %3: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = wrap custom State~0 %2 as Closure~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
in %3 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>

func bind#7 (%0: ((State~5<>, Closure~10<>), Int)): (Int, Int) =
let
  0: %1: (State~5<>, Closure~10<>)
   = tuple field 0 %0 as ((State~5<>, Closure~10<>), Int)
  1: %2: State~5<>
   = tuple field 0 %1 as (State~5<>, Closure~10<>)
  2: %3: Closure~10<>
   = tuple field 1 %1 as (State~5<>, Closure~10<>)
  3: %4: Int
   = tuple field 1 %0 as ((State~5<>, Closure~10<>), Int)
  4: %5: (State~5<>, Int)
   = (%2 as State~5<>, %4 as Int)
  5: %6: (Int, Int)
   = call run#5 (%5 as (State~5<>, Int))
  6: %7: Int
   = tuple field 0 %6 as (Int, Int)
  7: %8: Int
   = tuple field 1 %6 as (Int, Int)
  8: %9: State~4<>
   = call inc#0 (%8 as Int)
  9: %10: (State~4<>, Int)
   = (%9 as State~4<>, %7 as Int)
  10: %11: (Int, Int)
   = call run#4 (%10 as (State~4<>, Int))
in %11 as (Int, Int)

func dispatch#9 (%0: (Closure~12<●<'2>, ●<'3>, ●@●<'2>, ●@●<'3>, ●@●<'2>, ●@●<'3>>, {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})): State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>> =
let
  0: %1: Closure~12<●<'2>, ●<'3>, ●@●<'2>, ●@●<'3>, ●@●<'2>, ●@●<'3>>
   = tuple field 0 %0 as (Closure~12<●<'2>, ●<'3>, ●@●<'2>, ●@●<'3>, ●@●<'2>, ●@●<'3>>, {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  1: %2: {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}
   = tuple field 1 %0 as (Closure~12<&<∅>, &<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>, ●@●<∅>>, {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  2: %3: ({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))})
   = unwrap custom Closure~12 %1 as Closure~12<●<'2>, ●<'3>, ●@●<'2>, ●@●<'3>, ●@●<'2>, ●@●<'3>>
  3: %4: (({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}), {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = (%3 as ({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}), %2 as {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  4: %5: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = call index_leaves#3 (%4 as (({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}), {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))
in %5 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>

func run#4 (%0: (State~4<>, Int)): (Int, Int) =
let
  0: %1: State~4<>
   = tuple field 0 %0 as (State~4<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~4<>, Int)
  2: %3: Closure~6<>
   = unwrap custom State~4 %1 as State~4<>
  3: %4: (Closure~6<>, Int)
   = (%3 as Closure~6<>, %2 as Int)
  4: %5: (Int, Int)
   = call dispatch#10 (%4 as (Closure~6<>, Int))
in %5 as (Int, Int)

func inc#0 (%0: Int): State~4<> =
let
  0: %1: Int
   = 1
  1: %2: (Int, Int)
   = (%0 as Int, %1 as Int)
  2: %3: Int
   = add_int %2 as (Int, Int)
  3: %4: State~3<>
   = call set#0 (%3 as Int)
  4: %5: State~2<>
   = call pure#2 (%0 as Int)
  5: %6: (State~3<>, State~2<>)
   = (%4 as State~3<>, %5 as State~2<>)
  6: %7: State~4<>
   = call seq#0 (%6 as (State~3<>, State~2<>))
in %7 as State~4<>

func run#5 (%0: (State~5<>, Int)): (Int, Int) =
let
  0: %1: State~5<>
   = tuple field 0 %0 as (State~5<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~5<>, Int)
  2: %3: Closure~8<>
   = unwrap custom State~5 %1 as State~5<>
  3: %4: (Int, Int)
   = call get#0 (%2 as Int)
in %4 as (Int, Int)

func index_leaves#3 (%0: (({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}), {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})): State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>> =
let
  0: %1: ({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))})
   = tuple field 0 %0 as (({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}), {(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))})
  1: %2: {(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}
   = tuple field 0 %1 as ({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))})
  2: %3: {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}
   = tuple field 1 %0 as (({(Int, &<∅> Array (Byte)), &<∅> Boxed ((Tree~1<●@●<∅>, ●@●<∅>>, Tree~1<●@●<∅>, ●@●<∅>>))}), {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  3: %4: ({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
   = (%2 as {(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, %3 as {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  4: %5: ●<'1> Boxed (({(Int, ●@●<'2> Array (Byte)), ●@●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●@●<'4> Array (Byte)), ●@●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))
   = wrap boxed %4 as ({(Int, ●<'2> Array (Byte)), ●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●<'4> Array (Byte)), ●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))})
  5: %6: {(Int, ●<'0> Array (Byte)), ●<'1> Boxed (({(Int, ●@●<'2> Array (Byte)), ●@●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●@●<'4> Array (Byte)), ●@●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))}
   = wrap variant 1 %5 as ●<'1> Boxed (({(Int, ●@●<'2> Array (Byte)), ●@●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●@●<'4> Array (Byte)), ●@●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))
  6: %7: {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))}
   = wrap custom Tree~1 %6 as {(Int, ●<'0> Array (Byte)), ●<'1> Boxed (({(Int, ●@●<'2> Array (Byte)), ●@●<'3> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'2>, ●@●<'3>>))}, {(Int, ●@●<'4> Array (Byte)), ●@●<'5> Boxed ((Tree~1<●@●<'4>, ●@●<'5>>, Tree~1<●@●<'4>, ●@●<'5>>))}))}
  7: %8: State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>
   = call pure#1 (%7 as {(Int, ●<'0> Array (Byte)), ●<'1> Boxed ((Tree~1<●@●<'2>, ●@●<'3>>, Tree~1<●@●<'4>, ●@●<'5>>))})
in %8 as State~0<●<'0>, ●<'1>, ●@●<'2>, ●@●<'3>, ●@●<'4>, ●@●<'5>>

func dispatch#10 (%0: (Closure~6<>, Int)): (Int, Int) =
let
  0: %1: Closure~6<>
   = tuple field 0 %0 as (Closure~6<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~6<>, Int)
  2: %3: (State~3<>, Closure~7<>)
   = unwrap custom Closure~6 %1 as Closure~6<>
  3: %4: ((State~3<>, Closure~7<>), Int)
   = (%3 as (State~3<>, Closure~7<>), %2 as Int)
  4: %5: (Int, Int)
   = call bind#8 (%4 as ((State~3<>, Closure~7<>), Int))
in %5 as (Int, Int)

func seq#0 (%0: (State~3<>, State~2<>)): State~4<> =
let
  0: %1: State~3<>
   = tuple field 0 %0 as (State~3<>, State~2<>)
  1: %2: State~2<>
   = tuple field 1 %0 as (State~3<>, State~2<>)
  2: %3: (State~2<>)
   = (%2 as State~2<>)
  3: %4: Closure~7<>
   = wrap custom Closure~7 %3 as (State~2<>)
  4: %5: (State~3<>, Closure~7<>)
   = (%1 as State~3<>, %4 as Closure~7<>)
  5: %6: State~4<>
   = call bind#9 (%5 as (State~3<>, Closure~7<>))
in %6 as State~4<>

func pure#2 (%0: Int): State~2<> =
let
  0: %1: (Int)
   = (%0 as Int)
  1: %2: Closure~4<>
   = wrap custom Closure~4 %1 as (Int)
  2: %3: State~2<>
   = wrap custom State~2 %2 as Closure~4<>
in %3 as State~2<>

func set#0 (%0: Int): State~3<> =
let
  0: %1: (Int)
   = (%0 as Int)
  1: %2: Closure~5<>
   = wrap custom Closure~5 %1 as (Int)
  2: %3: State~3<>
   = wrap custom State~3 %2 as Closure~5<>
in %3 as State~3<>

func get#0 (%0: Int): (Int, Int) =
let
  0: %1: (Int, Int)
   = (%0 as Int, %0 as Int)
in %1 as (Int, Int)

func bind#8 (%0: ((State~3<>, Closure~7<>), Int)): (Int, Int) =
let
  0: %1: (State~3<>, Closure~7<>)
   = tuple field 0 %0 as ((State~3<>, Closure~7<>), Int)
  1: %2: State~3<>
   = tuple field 0 %1 as (State~3<>, Closure~7<>)
  2: %3: Closure~7<>
   = tuple field 1 %1 as (State~3<>, Closure~7<>)
  3: %4: Int
   = tuple field 1 %0 as ((State~3<>, Closure~7<>), Int)
  4: %5: (State~3<>, Int)
   = (%2 as State~3<>, %4 as Int)
  5: %6: (Int, ())
   = call run#7 (%5 as (State~3<>, Int))
  6: %7: Int
   = tuple field 0 %6 as (Int, ())
  7: %8: ()
   = tuple field 1 %6 as (Int, ())
  8: %9: (Closure~7<>, ())
   = (%3 as Closure~7<>, %8 as ())
  9: %10: State~2<>
   = call dispatch#11 (%9 as (Closure~7<>, ()))
  10: %11: (State~2<>, Int)
   = (%10 as State~2<>, %7 as Int)
  11: %12: (Int, Int)
   = call run#6 (%11 as (State~2<>, Int))
in %12 as (Int, Int)

func bind#9 (%0: (State~3<>, Closure~7<>)): State~4<> =
let
  0: %1: State~3<>
   = tuple field 0 %0 as (State~3<>, Closure~7<>)
  1: %2: Closure~7<>
   = tuple field 1 %0 as (State~3<>, Closure~7<>)
  2: %3: (State~3<>, Closure~7<>)
   = (%1 as State~3<>, %2 as Closure~7<>)
  3: %4: Closure~6<>
   = wrap custom Closure~6 %3 as (State~3<>, Closure~7<>)
  4: %5: State~4<>
   = wrap custom State~4 %4 as Closure~6<>
in %5 as State~4<>

func run#6 (%0: (State~2<>, Int)): (Int, Int) =
let
  0: %1: State~2<>
   = tuple field 0 %0 as (State~2<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~2<>, Int)
  2: %3: Closure~4<>
   = unwrap custom State~2 %1 as State~2<>
  3: %4: (Closure~4<>, Int)
   = (%3 as Closure~4<>, %2 as Int)
  4: %5: (Int, Int)
   = call dispatch#12 (%4 as (Closure~4<>, Int))
in %5 as (Int, Int)

func dispatch#11 (%0: (Closure~7<>, ())): State~2<> =
let
  0: %1: Closure~7<>
   = tuple field 0 %0 as (Closure~7<>, ())
  1: %2: ()
   = tuple field 1 %0 as (Closure~7<>, ())
  2: %3: (State~2<>)
   = unwrap custom Closure~7 %1 as Closure~7<>
  3: %4: ((State~2<>), ())
   = (%3 as (State~2<>), %2 as ())
  4: %5: State~2<>
   = call seq#1 (%4 as ((State~2<>), ()))
in %5 as State~2<>

func run#7 (%0: (State~3<>, Int)): (Int, ()) =
let
  0: %1: State~3<>
   = tuple field 0 %0 as (State~3<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (State~3<>, Int)
  2: %3: Closure~5<>
   = unwrap custom State~3 %1 as State~3<>
  3: %4: (Closure~5<>, Int)
   = (%3 as Closure~5<>, %2 as Int)
  4: %5: (Int, ())
   = call dispatch#13 (%4 as (Closure~5<>, Int))
in %5 as (Int, ())

func dispatch#12 (%0: (Closure~4<>, Int)): (Int, Int) =
let
  0: %1: Closure~4<>
   = tuple field 0 %0 as (Closure~4<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~4<>, Int)
  2: %3: (Int)
   = unwrap custom Closure~4 %1 as Closure~4<>
  3: %4: ((Int), Int)
   = (%3 as (Int), %2 as Int)
  4: %5: (Int, Int)
   = call pure#3 (%4 as ((Int), Int))
in %5 as (Int, Int)

func seq#1 (%0: ((State~2<>), ())): State~2<> =
let
  0: %1: (State~2<>)
   = tuple field 0 %0 as ((State~2<>), ())
  1: %2: State~2<>
   = tuple field 0 %1 as (State~2<>)
  2: %3: ()
   = tuple field 1 %0 as ((State~2<>), ())
in %2 as State~2<>

func dispatch#13 (%0: (Closure~5<>, Int)): (Int, ()) =
let
  0: %1: Closure~5<>
   = tuple field 0 %0 as (Closure~5<>, Int)
  1: %2: Int
   = tuple field 1 %0 as (Closure~5<>, Int)
  2: %3: (Int)
   = unwrap custom Closure~5 %1 as Closure~5<>
  3: %4: ((Int), Int)
   = (%3 as (Int), %2 as Int)
  4: %5: (Int, ())
   = call set#1 (%4 as ((Int), Int))
in %5 as (Int, ())

func pure#3 (%0: ((Int), Int)): (Int, Int) =
let
  0: %1: (Int)
   = tuple field 0 %0 as ((Int), Int)
  1: %2: Int
   = tuple field 0 %1 as (Int)
  2: %3: Int
   = tuple field 1 %0 as ((Int), Int)
  3: %4: (Int, Int)
   = (%3 as Int, %2 as Int)
in %4 as (Int, Int)

func set#1 (%0: ((Int), Int)): (Int, ()) =
let
  0: %1: (Int)
   = tuple field 0 %0 as ((Int), Int)
  1: %2: Int
   = tuple field 0 %1 as (Int)
  2: %3: Int
   = tuple field 1 %0 as ((Int), Int)
  3: %4: ()
   = ()
  4: %5: (Int, ())
   = (%2 as Int, %4 as ())
in %5 as (Int, ())

