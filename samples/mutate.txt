get(arr: Array a, i: Int): a =
  let (x, _) = item(arr, i) in
  x

set(arr: Array a, i: Int, val: a): Array a =
  let (_, hole) = item(arr, i) in
  hole(val)

favs : Array Int =
  [1, 2, 3, 4, 5]

favs_hole : (Int, Int -> Array Int) =
  item([1, 2, 3], 0)


map_from(arr: Array a, f: a -> a, idx: Int): Array a =
  if idx = len(arr) {
    arr
  } else {
    let (x, hole) = item(arr, idx) in
    map_from(hole(f(x)), f, idx + 1)
  }

map(arr: Array a, f: a -> a): Array a =
  map_from(arr, f, 0)

proc for_each_from(arr: Array a, f: proc a -> b, idx: Int): () =
  if idx = len(arr) {
    ()
  } else {
    let (x, _) = item(arr, idx) in
    let _ = do f(x) in
    do for_each_from(arr, f, idx + 1)
  }

proc for_each(arr: Array a, f: proc a -> b): () =
  do for_each_from(arr, f, 0)

proc print_all(arr: Array Int): () =
  do for_each(arr, proc \i -> do output(int_to_string(i)))

proc print_and(arr: Array Int): Array Int =
  let _ = do output("vvvvvvv") in
  let _ = do print_all(arr) in
  let _ = do output("^^^^^^^") in
  arr

reverse_from(arr: Array a, idx: Int): Array a =
  if idx >= len(arr) / 2 {
    arr
  } else {
    reverse_from(
      swap(arr, idx, len(arr) - idx - 1),
      idx + 1
    )
  }

reverse(arr: Array a): Array a =
  reverse_from(arr, 0)

swap(arr: Array a, left_idx: Int, right_idx: Int): Array a =
  let (left_el, left_hole) = item(arr, left_idx) in
  let right_el = get(arr, right_idx) in
  set(left_hole(right_el), right_idx, left_el)


swap_using_item(arr: Array a, left_idx: Int, right_idx: Int): Array a =
  let (left_el, left_hole) = item(arr, left_idx) in
  let (right_el, _) = item(arr, right_idx) in
  let (_, right_hole) = item(left_hole(right_el), right_idx) in
  right_hole(left_el)

proc main(): () =
  let arr = do print_and(favs) in
  let better = do print_and(map(favs, \x -> x + 1)) in
  let even_better = do print_and(map(better, \x -> x * x)) in
  let now_backwards = do print_and(reverse(even_better)) in
  ()



/////////////////////////////////////////////////////////////////////////
// CONCAT LIB ///////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

concat_from(a: Array t, b: Array t, i: Int): Array t =
  if i = len(b) {
    a
  } else {
    concat_from(push(a, get(b, i)), b, i + 1)
  }

concat(a: Array t, b: Array t): Array t =
  concat_from(a, b, 0)

nat_to_string(i: Int): Array Byte =
  let digit_to_string = \d ->
    match d {
        0 -> "0",
        1 -> "1",
        2 -> "2",
        3 -> "3",
        4 -> "4",
        5 -> "5",
        6 -> "6",
        7 -> "7",
        8 -> "8",
        9 -> "9",
        _ -> "",
    } in
  if i = 0 {
    ""
  } else {
    concat(nat_to_string(i / 10), digit_to_string(i - i / 10 * 10))
  }

int_to_string(i: Int): Array Byte =
  if i = 0 {
    "0"
  } else if i < 0 {
    concat("-", nat_to_string(0 - i))
  } else {
    nat_to_string(i)
  }



/////////////////////////////////////////////////////////////////////////
// FUNCTION LIB /////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

id(x : a) : a =
  x

const_curry: a -> b -> a =
  \x -> \y -> x

const(x : a, y : b) : a =
  x

compose(f: a -> b, g: b -> c): (a -> c) =
  \x -> g(f(x))

