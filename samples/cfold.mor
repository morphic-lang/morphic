// based off https://github.com/koka-lang/koka/blob/b3122869ac74bfb6f432f7e76eeb723b1f69a491/test/bench/koka/cfold.kk

module Core = file "lib/core/core.mor"
  expose {
    module Io expose { writeln },
    module String expose { int_to_string },
    module Math expose { cmp_max },
  }

type Expr {
  Var(Int),
  Val(Int),
  Add(Expr, Expr),
  Mul(Expr, Expr),
}

mk_expr(n: Int, v: Int): Expr =
  if n = 0 {
   if v=0 { Var(1) } else { Val(v) }
  } else {
    Add( mk_expr(n - 1, v+1), mk_expr(n - 1, cmp_max(v - 1,0)) )
  }

append_add( e0 : Expr, e3 : Expr) : Expr =
  match e0 {
    Add(e1,e2) -> Add(e1, append_add(e2,e3)),
    _          -> Add(e0,e3),
  }

append_mul( e0 : Expr, e3 : Expr) : Expr =
  match e0 {
    Mul(e1,e2) -> Mul(e1, append_mul(e2,e3)),
    _          -> Mul(e0,e3),
  }

reassoc( e : Expr ) : Expr =
  match e {
    Add(e1,e2) -> append_add(reassoc(e1), reassoc(e2)),
    Mul(e1,e2) -> append_mul(reassoc(e1), reassoc(e2)),
    _ -> e,
  }

cfold( e : Expr) : Expr =
  match e {
    Add(e1,e2) ->
      let e1_ = cfold(e1) in
      let e2_ = cfold(e2) in
      match e1_ {
        Val(a) -> match e2_ {
          Val(b)        -> Val(a+b),
          Add(f,Val(b)) -> Add(Val(a+b),f),
          Add(Val(b),f) -> Add(Val(a+b),f),
          _             -> Add(e1_,e2_),
        },
        _ -> Add(e1_,e2_),
      },
    Mul(e1,e2) ->
      let e1_ = cfold(e1) in
      let e2_ = cfold(e2) in
      match e1_ {
        Val(a) -> match e2_ {
          Val(b)        -> Val(a*b),
          Mul(f,Val(b)) -> Mul(Val(a*b),f),
          Mul(Val(b),f) -> Mul(Val(a*b),f),
          _             -> Mul(e1_,e2_),
        },
        _ -> Mul(e1_,e2_),
      },
    _ -> e,
  }

eval(e : Expr) : Int =
  match e {
    Var(_)   -> 0,
    Val(v)   -> v,
    Add(l,r) -> eval(l) + eval(r),
    Mul(l,r) -> eval(l) * eval(r),
  }

repeat(count : Int, func: () -> ()): () =
  if count = 0 { () } else {
    let x = func() in
    repeat(count - 1, func)
  }


// don't know what this function is for
test() : () =
  repeat(100,\() ->
    let e = mk_expr(16,1) in
    let v1 = eval(e) in
    let v2 = e |> reassoc() |> cfold() |> eval() in ())

// the original example has mk_expr(20, 1) but that stack overflows
proc main(): () =
  let e = mk_expr(16, 1) in
  let v1 = eval(e) in
  let v2 = e |> reassoc() |> cfold() |> eval() in
  do writeln(int_to_string(v1)) then
  do writeln(int_to_string(v2))
