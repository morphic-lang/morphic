type State s r {
  State(s -> (s, r)),
}

get: State s s =
  State(\s -> (s, s))

set(s: s): State s () =
  State(\_ -> (s, ()))

modify(f: s -> s): State s () =
  State(\s -> (f(s), ()))

pure(x: r): State s r =
  State(\s -> (s, x))

run(body: State s r, init: s): (s, r) =
  let State(f) = body in
  f(init)

bind(fst: State s a, cont: a -> State s b): State s b =
  State(\s1 ->
    let (s2, res) = run(fst, s1) in
    run(cont(res), s2)
  )

seq(fst: State s a, snd: State s b): State s b =
  bind(fst, \_ -> snd)

inc: State Int Int =
  bind(get, \curr -> seq(set(curr + 1), pure(curr)))

type Tree a {
  Leaf(a),
  Branch(Tree a, Tree a),
}

index_leaves(tree: Tree a): State Int (Tree (Int, a)) =
  match tree {
    Leaf(val) -> bind(inc, \idx -> pure(Leaf(idx, val))),

    Branch(left, right) ->
      bind(index_leaves(left), \left_indexed ->
        bind(index_leaves(right), \right_indexed ->
          pure(Branch(left_indexed, right_indexed))
        )
      )
  }

proc main(): () =
  let tree = Branch(Leaf("foo"), Branch(Branch(Leaf("bar"), Leaf("baz")), Leaf("quux"))) in
  let (_, indexed) = run(index_leaves(tree), 0) in
  ()
